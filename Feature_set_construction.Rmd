---
title: "Contruction of a comprehensive *E.coli* feature set"
author: "Claire Rioualen"
date: '`r Sys.Date()`'
output:
 html_document:
   fig_caption: yes
   highlight: zenburn
   self_contained: yes
   theme: cerulean
   toc: yes
   toc_depth: 5
   toc_float: yes
   number_sections: true
   code_folding: hide


---
<style type="text/css">

body{ /* Normal  */
      font-size: 14px;
  }
</style>

```{r init, include=FALSE}
setwd("/Users/rioualen/Google Drive/Work/Ecoli_mapping_project/Feature_set")
date <- Sys.Date()
source(file = "env.r")
```


```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "/Users/rioualen/Google Drive/Work/Ecoli_mapping_project/Feature_set")
knitr::opts_chunk$set(echo = FALSE, include = TRUE, warning = FALSE, message = FALSE, cache = TRUE, eval = FALSE, results = 'asis', fig.width=12, fig.height=6, fig.align = 'center')

date <- Sys.Date()
load(file = paste0("Feature_set_construction_", date, ".Rdata"))
```

```{r libs-n-functions, eval = TRUE}
library(ggplot2)
library(plotly)
library(dplyr)
library(DT)
library(grDevices)
library(gridExtra)
library(igraph)
library(patchwork)
library(RMariaDB)
library(scales)
library(sqldf)
library(stringr)
library(tidyr)
library(UpSetR)
library(viridis)

devtools::load_all("EcoliGenes")

feature_set_dir <- paste0("Feature_set_", date)
dir.create(feature_set_dir)

concat_uniq <- function(x, sep = ","){
  paste0(unique(na.omit(x)), collapse = sep)
}

concat_uniq2 <- function(..., sep = ","){
    vec <- paste(na.omit(c(...)), collapse = sep)
    res <- gsub("^,", "", paste(unique(sort(str_split(vec, pattern = ",")[[1]])), collapse = sep))
    res
}

random_palette <- function(n){
  sample(grDevices::colors()[grep("gr(a|e)y", grDevices::colors(), invert = T)], n)
}

```

```{r hide-pwd}
local({
  hook_source <- knitr::knit_hooks$get('source')
  knitr::knit_hooks$set(source = function(x, options) {
    x <- x[!grepl('# SECRET!$', x)]
    hook_source(x, options)
  })
})
```


This documents reports the details behind the generation of the *E. coli* feature set. It is based mainly on RegulonDB's curated data, and a few other sources detailed hereafter. 

![Ecoli feature set](img/Ecoli_feature_set.png)

The following sets are generated:

**1. Gene set**

A table generated by merging all gene-related information from RegulonDB and Zika, indexed by a *consensus bnumber*, and containing exhaustive synonyms for genes and their products.

**2. TSS set and Promoter set**

TSSs are gathered from RegulonDB, HT datasets (Mendoza-Vargas et al., 2009; Kim et al., 2012; Cho eet al., 2014; Thomason et al., 2014; Yan et al., 2018), and an unpublished collection from the Wade group. Merged on the basis of their coordinates and strand.

Promoters are regions containing 1 or more TSSs, where **each TSS is at most 4 bp away from another TSS**. A promoter opens with a TSS, and expands as long as there is another TSS in the following 4 positions (using a 5-nt window, meaning the maximum "empty" space between them is 3 nt). It closes with the last TSS of the sequence. 

![Promoter definition](img/Promoter_definition.png){width=70%}

**3. Transcription unit set and co-transcribed genes set**

Transcription units are defined by their **unique coordinates and strand**. Experimental TUs are extracted from RegulonDB, HT TUs from a public dataset (Yan et al., 2018), and custom *orphan* TUs are made of orphans genes. They are then merged on the basis of their coordinates and strand.

Every group of co-transcribed genes (CTG) is made of **genes that are co-transcribed together at least once**. The CTG set is derived from the TU set. TUs that contain exactly the same complete genes are grouped into a CTG sets, and the widest coordinates are kept. A given gene can be in several CTG sets, but 2 CTG sets cannot contains exactly the same genes. 

Both sets come with a "operon_name" column. Here, an operon is a set of adjacent genes made of *"one or several mutually overlapping transcription units that are transcribed in the same direction and share at least one gene"*, as proposed by Mejía-Almonte et al. (by Mejía-Almonte et al., 2020). It is purely informative, and may not match with known operons. 

![TU and CTG definition](img/TU_CTG_definition.png){width=90%}


**4. Binding sites set**

Set of curated binding sites from RegulonDB. They are merged using their coordinates, TF bnumber and effect (+ or -). When the TF is a heterodimer, 2 entries are created: one per bnumber.

# Gene set

Master gene table, with exhaustive synonyms gathered from RegulonDB, Ecocyc, Zika, etc. 

```{r master-gene}

master_gene_set <- EcoliGenes::read_master_gene_file()

```

<!-- ## RegulonDB genes table -->

<!-- Basically a join on gene, product, synonyms and bnumbers tables queried from RegulonDB. A column is added to state whether the gene is considered TF-coding or not. -->

<!-- *Note the pseudogene "insI2" has its symbol changed for its RegulonDB ID, for there is another gene that shares the same symbol, but a distinct bnumber.* -->

<!-- ```{r query-regulon-genes} -->


<!-- query_1 <- " -->
<!-- select  -->
<!--   G.gene_id as RegulonDB_gene_id, -->
<!--   G.gene_name as RegulonDB_symbol, -->
<!--   group_concat(distinct GBNUM.bnumber) as RegulonDB_bnumber, -->
<!-- 	  min(G.gene_posleft) as RegulonDB_start, -->
<!-- 	  min(G.gene_posright) as RegulonDB_stop, -->
<!-- 	  group_concat(distinct G.gene_strand) as RegulonDB_strand, -->
<!-- 	  group_concat(distinct G.gene_type) as RegulonDB_type, -->
<!-- 	  group_concat(distinct P.product_id) as RegulonDB_product_id, -->
<!-- 	  group_concat(distinct P.product_name) as RegulonDB_product_name, -->
<!-- 	  group_concat(distinct P.product_type) as RegulonDB_product_type, -->
<!-- 	  group_concat(distinct OBSYN.object_synonym_name) as gene_synonyms, -->
<!-- 	  group_concat(distinct OBSYN2.object_synonym_name) as product_synonyms -->
<!-- 		from  -->
<!-- 			(select gene_id,gene_name,gene_posleft,gene_posright,gene_strand,gene_type from regulondb.GENE) as G -->
<!-- 		left join (select ecocyc_id,bnumber,gene_id from regulondb.GENE_BNUMBER_TMP) as GBNUM -->
<!--         on G.gene_id = GBNUM.gene_id -->
<!--         left join (select * from regulondb.GENE_PRODUCT_LINK) as GPLN -->
<!--         on G.gene_id = GPLN.gene_id -->
<!--         left join (select product_id,product_name,product_type from regulondb.PRODUCT) as P -->
<!--         on GPLN.product_id = P.product_id -->
<!--         left join regulondb.OBJECT_SYNONYM as OBSYN -->
<!--         on G.gene_id = OBSYN.object_id   -->
<!--          left join regulondb.OBJECT_SYNONYM as OBSYN2 -->
<!--         on P.product_id = OBSYN2.object_id -->
<!-- 	    group by G.gene_id,G.gene_name -->
<!-- " -->
<!-- genes_and_products <- dbGetQuery(regulondb_access, query_1) -->

<!-- query_2 <- "select product_id from PRODUCT_TF_LINK" -->

<!-- tfs_products <- unique(dbGetQuery(regulondb_access, query_2)$product_id) -->

<!-- genes_and_products <- genes_and_products %>% -->
<!--   dplyr::mutate(RegulonDB_strand = ifelse(RegulonDB_strand == "reverse", "-", ifelse(RegulonDB_strand == "forward", "+",NA))) %>% -->
<!--   dplyr::mutate(RegulonDB_TF = ifelse(RegulonDB_product_id %in% tfs_products,1,0)) %>% -->
<!--   mutate_at("RegulonDB_symbol", ~replace(., RegulonDB_bnumber == 'b4708', 'ECK125240991')) ### Changed manually, since there's 2 genes with the same RegulonDB_symbol and we don't want them to be merged -->

<!-- dbDisconnect(regulondb_access) -->
<!-- ``` -->

<!-- ## Zika genesView -->

<!-- Zika's genesView is queried. An additional column with parsed bnumbers is added.  -->

<!-- ```{r query-zika} -->

<!-- ## Part 1: get proms and genes associated to TUs from RegulonDB -->
<!-- query_2 <- "SELECT * FROM ecoli_project_final.genesView;" -->

<!-- zika_genes <- dbGetQuery(zikadb_access, query_2) -->

<!-- dbDisconnect(regulondb_access) -->

<!-- zika_genes_parsed <- zika_genes %>% -->
<!--   dplyr::rename(Zika_gene_id = gene_id, -->
<!--                 Zika_bnumber = bnumber, -->
<!--                 Zika_symbol = symbol, -->
<!--                 Zika_product = product, -->
<!--                 Zika_start = start, -->
<!--                 Zika_stop = stop, -->
<!--                 Zika_strand = strand, -->
<!--                 Zika_type = type, -->
<!--   							Zika_essentiality = essentiality, -->
<!--                 Zika_TF = TF -->
<!--                 ) %>% -->
<!--   dplyr::mutate(Zika_parsed_bnum = ifelse(grepl('_', Zika_bnumber), ifelse(grepl('^b', Zika_bnumber), stringr::str_split(Zika_bnumber, '_', simplify = T), Zika_bnumber), Zika_bnumber)) -->
<!-- ``` -->

<!-- ## Merge -->

<!-- * Genes are first retrieved from RegulonDB and Zika separately -->
<!-- * Tables are joined using bnumbers (or parsed bnumbers, for sRNA in Zika) -->
<!-- * Genes that are not merged during this first step are then joined based on their symbol -->
<!-- * Coherency of coordinates and strand is checked -->
<!-- * In case some information differs between RegulonDB and Zika, the priority is given to RegulonDB -->
<!-- * A third join is made based on coordinates identity -->

<!-- <!-- *Note: 4 genes that don't have any coordinates in either database are given "fake" unique coordinates manually (ackB, alaB, dgd and ECK125135293).* --> -->

<!-- * 6 new columns are added: -->

<!--   * **Consensus_bnumber**: if different, Zika's is kept; if absent, Zika internal ID is kept, else, RegulonDB internal "bnumber" is kept. -->
<!--   * **Consensus_symbol**: if different, Zika's is kept; if absent, Zika internal ID is kept. -->
<!--   * **Consensus_start**: if different, Zika's is kept.  -->
<!--   * **Consensus_stop**: if different, Zika's is kept.  -->
<!--   * **Consensus_strand**: if different, Zika's is kept.  -->
<!--   * **Consensus_TF**: if 0, gene doesn't code for a TF; if 1, gene considered TF-coding in either database; if 2, gene considered TF-coding in both databases.  -->


<!-- *Note: A few gene synonyms are added manually:*  -->

<!-- * *deprecated istR-1, gatR_2 and insN-2 become istR, gatR and insN* -->
<!-- * *b4694 is added to yagP synonyms* -->
<!-- * *b4600 is added to ydjF synonyms* -->
<!-- * ... -->

<!-- ```{r merge-genes} -->
<!-- ## Manually added synonyms -->
<!-- ## raiZ/b4805, C0293/b4806 -->
<!-- ## istR-1/istR -->
<!-- Consensus_symbol <- c("gatR", "insO", "istR", "yagP", "ydfJ", "ydiU", "yjhB", "ydgV", "yhjC", "yejM", "yhcH",  "yeeX", "ygeR", "yedR", "yraP", "yddW", "yhcB", "yafK", "ytfL", "yebS", "yjhC") -->
<!-- add_synonyms <- c("gatR_2", "insN-2", "istR-1", "b4694", "b4600", "selO", "nanX", "mdtU", "rcdB", "lapC", "nanQ", "tmaR", "actS", "drpB", "dolP", "digH", "zapG", "dpaA", "paeA", "letA", "nanY") -->
<!-- manual_synonyms <- data.frame(Consensus_symbol, add_synonyms) -->



<!-- ## Join RegulonDB and Zika genes on bnumber, then symbol, then coordinates -->
<!-- regulon_zika_genes <- genes_and_products %>% -->
<!--   # dplyr::filter(!RegulonDB_type %in% c("Phantom Gene" , "Pseudo Gene")) %>% -->
<!--   ## Join RegulonDB and Zika on bnumbers -->
<!-- 	dplyr::full_join(zika_genes_parsed, by = c("RegulonDB_bnumber" = "Zika_parsed_bnum")) %>% -->
<!--   dplyr::mutate(Consensus_bnumber = Zika_bnumber) %>% -->
<!-- 	dplyr::mutate(Consensus_symbol = ifelse( ((is.na(RegulonDB_symbol))&(is.na(Zika_symbol))), Zika_bnumber, -->
<!--                           ifelse(is.na(Zika_symbol), RegulonDB_symbol, -->
<!--                           			 ifelse(is.na(RegulonDB_symbol), Zika_symbol, RegulonDB_symbol)))) %>% -->
<!--   ## Join on symbol -->
<!--   dplyr::group_by(Consensus_symbol) %>% -->
<!-- 	dplyr::summarise(Consensus_bnumber = concat_uniq(Consensus_bnumber), -->
<!-- 									RegulonDB_gene_id = concat_uniq(RegulonDB_gene_id), -->
<!-- 									RegulonDB_symbol = concat_uniq(RegulonDB_symbol), -->
<!-- 									RegulonDB_bnumber = concat_uniq(RegulonDB_bnumber), -->
<!-- 									RegulonDB_start = first(RegulonDB_start), -->
<!-- 									RegulonDB_stop = first(RegulonDB_stop), -->
<!-- 									RegulonDB_strand = concat_uniq(RegulonDB_strand), -->
<!-- 									RegulonDB_type = concat_uniq(RegulonDB_type), -->
<!-- 									RegulonDB_product_id = concat_uniq(RegulonDB_product_id), -->
<!-- 									RegulonDB_product_name = concat_uniq(RegulonDB_product_name), -->
<!-- 									RegulonDB_product_type = concat_uniq(RegulonDB_product_type), -->
<!-- 									RegulonDB_TF = mean(RegulonDB_TF), -->
<!-- 									RegulonDB_type = concat_uniq(RegulonDB_type), -->
<!-- 									Zika_gene_id = concat_uniq(Zika_gene_id), -->
<!-- 									Zika_symbol = concat_uniq(Zika_symbol), -->
<!-- 									Zika_bnumber = concat_uniq(Zika_bnumber), -->
<!-- 									Zika_essentiality = concat_uniq(Zika_essentiality), -->
<!-- 									Zika_product = concat_uniq(Zika_product), -->
<!-- 									Zika_start = first(Zika_start), -->
<!-- 									Zika_stop = first(Zika_stop), -->
<!-- 									Zika_strand = concat_uniq(Zika_strand), -->
<!-- 									Zika_type = concat_uniq(Zika_type), -->
<!-- 									Zika_TF = mean(Zika_TF), -->
<!-- 									gene_synonyms = concat_uniq(gene_synonyms), -->
<!-- 									product_synonyms = concat_uniq2(product_synonyms, RegulonDB_product_id)) %>% -->
<!-- 	mutate_all(na_if,"") %>% -->
<!-- 	rowwise() %>% -->
<!--   dplyr::mutate(Consensus_TF = sum(Zika_TF, RegulonDB_TF, na.rm=T)) %>% -->
<!--   dplyr::mutate(Consensus_start = ifelse(is.na(RegulonDB_start), Zika_start, -->
<!--                           ifelse(is.na(Zika_start), RegulonDB_start, -->
<!--                                  ifelse(RegulonDB_start==Zika_start, Zika_start, Zika_start)))) %>% -->
<!--   dplyr::mutate(Consensus_stop = ifelse(is.na(RegulonDB_stop),Zika_stop, -->
<!--                           ifelse(is.na(Zika_stop),RegulonDB_stop, -->
<!--                                  ifelse(RegulonDB_stop==Zika_stop,Zika_stop,Zika_stop)))) %>% -->
<!--   dplyr::mutate(Consensus_strand = ifelse(is.na(RegulonDB_strand),Zika_strand, -->
<!--                           ifelse(is.na(Zika_strand),RegulonDB_strand, -->
<!--                                  ifelse(RegulonDB_strand==Zika_strand,Zika_strand,Zika_strand))))  %>% -->
<!--   ## Join on coordinates and strand -->
<!--   mutate(coords = paste0(Consensus_start, "_", Consensus_stop, "_", Consensus_strand)) %>% -->
<!--   dplyr::group_by(coords) %>% -->
<!-- 	dplyr::summarise(across(where(is.factor), concat_uniq), -->
<!-- 						across(where(is.character), concat_uniq), -->
<!-- 						across(where(is.numeric), min)) %>% -->
<!-- 	mutate_all(na_if,"") %>% -->
<!--   dplyr::mutate(Consensus_symbol = ifelse(is.na(RegulonDB_symbol),Zika_symbol, -->
<!--                           ifelse(is.na(Zika_symbol),RegulonDB_symbol, -->
<!--                                  ifelse(RegulonDB_symbol==Zika_symbol,Zika_symbol,Zika_symbol)))) %>% -->
<!--   dplyr::mutate(Consensus_bnumber = ifelse(is.na(RegulonDB_bnumber),Zika_bnumber, -->
<!--                           ifelse(is.na(Zika_bnumber),RegulonDB_bnumber, -->
<!--                                  ifelse(RegulonDB_bnumber==Zika_bnumber,Zika_bnumber,Zika_bnumber))))  %>% -->
<!--   ## Add synonyms -->
<!--   dplyr::left_join(manual_synonyms, by = ("Consensus_symbol")) %>% -->
<!--   dplyr::rowwise() %>% -->
<!--   dplyr::mutate(gene_synonyms = concat_uniq2(gene_synonyms, RegulonDB_bnumber, RegulonDB_gene_id, RegulonDB_symbol, Zika_symbol, Zika_bnumber, add_synonyms)) -->
<!-- ``` -->

<!-- ```{r write-gene-set} -->
<!-- ## Remove NA genes, arrange rows and columns -->
<!-- gene_set  <- regulon_zika_genes %>%  -->
<!--   dplyr::filter_at(vars(Consensus_bnumber, Consensus_symbol, Consensus_start, Consensus_stop, Consensus_strand, Zika_gene_id), all_vars(!is.na(.))) %>% -->
<!--   dplyr::select(Consensus_bnumber, Consensus_symbol, Consensus_start, Consensus_stop, Consensus_strand, Consensus_TF,  -->
<!--                 gene_synonyms, product_synonyms, everything(), -coords, -add_synonyms) %>% -->
<!--   dplyr::arrange(Consensus_start) -->

<!-- write.table(gene_set, file = paste0(feature_set_dir, "/gene_set_file_", date, ".tsv"), sep="\t", col.names = T, row.names = F) -->

<!-- # gene_set_bed <- gene_set %>% -->
<!-- #   mutate(chromosome = "Chromosome") %>% -->
<!-- # 	select(chromosome, Consensus_start, Consensus_stop, Consensus_symbol, Consensus_bnumber, Consensus_strand) %>% -->
<!-- # 	arrange(Consensus_start) %>% -->
<!-- # 	mutate_all(na_if,"") %>% -->
<!-- # 	tidyr::drop_na() -->
<!-- #  -->
<!-- # write.table(gene_set_bed, file = "TEMP_MASTER_GENE_BED.tsv", col.names = F,  row.names = F, quote = F, sep = "\t") -->

<!-- ``` -->

# TSSs and promoters

The following files are created:

```{r create-filenames-prom}
tss_set_file <- paste0(feature_set_dir, "/tss_set_", date, ".tsv")
promoter_set_file <- paste0(feature_set_dir, "/promoter_set_", date, ".tsv")
tss_promoter_map_file <- paste0(feature_set_dir, "/tss_promoter_map_", date, ".tsv")
```

**`r tss_set_file`**

* **tss_id:** custom id (CTSSxxx)
* **start:** +1
* **stop:** +1
* **strand:** "+" or "-"
* **name:** depending on source
* **source:** datasets from where it was collected
* **condition:** depending on source
* **HT:** boolean, 1 if appears in HT TSSs at least once, else 0
* **classic:**  boolean, 1 if appears in classic TSSs at least once, else 0
* **prediction:**  boolean, 1 if appears in prediction TSSs at least once, else 0
* **orientation:** depending on source
* **type:** "TSS"
* **alt_id:** id from source


**`r promoter_set_file`**

* **promoter_id:** custom id (CPROMxxx)
* **start:** left TSS +1 position
* **stop:** right TSS +1 position
* **strand:** "+" or "-"
* **type:** "Promoter"

**`r tss_promoter_map_file`**

* **promoter_id:** custom id (CPROMxxx)
* **tss_id:** custom id (CTSSxxx)

## Sources

### HT TSS

#### Wade data

* Get Wade TSSs from Zika database 

```{r wade}
zikadb_access <- dbConnect(RMariaDB::MariaDB(),
                       username = zika_username,
                       password = zika_password,
                       dbname = zika_dbname,
                       host = zika_host,
                       port = zika_port)
query_wade_promoters <- "select * from ecoli_project_final.ecoli_features where source = 'Wade' and type = 'Promoter'"
wade_promoters <- dbGetQuery(zikadb_access, query_wade_promoters)
dbDisconnect(zikadb_access)

ht_wade_tss <- wade_promoters %>%
  dplyr::mutate(alt_id = name, technology = "HT", source = "Wade", orientation = NA, condition = NA) %>%
  dplyr::select(name, start, stop, strand, orientation, condition, technology, source, alt_id)
```

#### Morett data

* Files were downloaded on 2021/03/19 [here](http://regulondb.ccg.unam.mx/highthroughputdatasetssearch?term=all) ([Reference](https://doi.org/10.1371/journal.pone.0007526))
* Genome coordinates were converted from version U00096.2 to version U00096.3 [here](https://biocyc.org/ECOLI/map-seq-coords-form?chromosome=COLI-K12) 
* This dataset is composed of 3 files formatted differently:
  * One file has TSS left and right positions, unique position is selected depending on strand
  * Two files have associated gene's left and right coordinates, and relative position of the TSS to the gene (unique position is calculated depending on strand). These files don't have relative orientation information

```{r ht-morett}
ht1 <- read.delim("TSS/HT/morett/HTRI00000225_HighThroughputDataSets_up.txt", comment.char = "#", header = F)
ht2 <- read.delim("TSS/HT/morett/HTRI00000229_HighThroughputDataSets_up.txt", comment.char = "#", header = F)
ht3 <- read.delim("TSS/HT/morett/HTRI00000230_HighThroughputDataSets_up.txt", comment.char = "#", header = F)

## Dataset 1: promoter position = max_frequency column

ht1_format <- ht1 %>% 
  dplyr::rename(name = V10, left = V4, right = V5, strand = V9, orientation = V11, condition = V3) %>%
  dplyr::mutate(start = ifelse(strand == "forward", left, ifelse(strand == "reverse", right,NA))) %>%
  dplyr::mutate(stop = start) %>% 
  dplyr::select(name, start, stop, strand, orientation, condition) 

## Datasets 2 and 3: promoter position = gene start + relative orientation

ht2_format <- ht2 %>% 
  dplyr::rename(name = V10, start = V6, strand = V9, left = V4, right = V5, relative_pos = V11, condition = V3) %>%
  dplyr::mutate(start = ifelse(strand == "forward", left + relative_pos, ifelse(strand == "reverse", right - relative_pos,NA)),
                stop = start,
                orientation = NA) %>%
  dplyr::select(name, start, stop, strand, orientation, condition) 

ht3_format <- ht3 %>% 
  dplyr::rename(name = V10, start = V6, strand = V9, left = V4, right = V5, relative_pos = V11, condition = V3) %>%
  dplyr::mutate(start = ifelse(strand == "forward", left + relative_pos, ifelse(strand == "reverse", right - relative_pos,NA)),
                stop = start,
                orientation = NA) %>%
  dplyr::select(name, start, stop, strand, orientation, condition) 

## Merge all 3 datasets and create alt_ids

ht_morett_tss <- rbind.data.frame(ht1_format, ht2_format, ht3_format) %>% 
  dplyr::mutate(technology = "HT") %>%
  dplyr::mutate(source = "Morett") %>%
  dplyr::mutate(condition = ifelse(grepl("454_Dataset", condition), "454_data", 
                                   ifelse(grepl("RACE_Dataset", condition), "RACE_data", 
                                          ifelse(grepl("monophosphate", condition), "triphosphate_enrichment", NA)))) %>%
  dplyr::arrange(start) %>%
  dplyr::mutate(alt_id = paste0("HT_Morett_", row_number())) %>%
  dplyr::mutate(strand = ifelse(strand == "reverse", "-", ifelse(strand == "forward", "+",NA)))

```

#### Storz data

* Files were downloaded on 2021/03/19 [here](http://regulondb.ccg.unam.mx/highthroughputdatasetssearch?term=all) ([Reference](https://doi.org/10.1128/jb.02096-14))
* Genome coordinates were converted from version U00096.2 to version U00096.3 [here](https://biocyc.org/ECOLI/map-seq-coords-form?chromosome=COLI-K12) 

```{r ht-storz}
ht4 <- read.delim("TSS/HT/storz/HTRI00000227_HighThroughputDataSets_up.txt", comment.char = "#", header = F)
ht5 <- read.delim("TSS/HT/storz/HTRI00000228_HighThroughputDataSets_up.txt", comment.char = "#", header = F)
ht6 <- read.delim("TSS/HT/storz/HTRI00000458_HighThroughputDataSets_up.txt", comment.char = "#", header = F)

ht_storz_tss <- rbind.data.frame(ht4, ht5, ht6)  %>% 
  dplyr::rename(name = V10, start = V4, strand = V9, orientation = V11, condition = V3) %>%
  dplyr::mutate(stop = start) %>%
  dplyr::mutate(technology = "HT") %>%
  dplyr::mutate(source = "Storz") %>%
  dplyr::mutate(condition = ifelse(grepl("LB_2.0", condition), "LB_2.0", 
                                   ifelse(grepl("LB_0.4", condition), "LB_0.4", 
                                          ifelse(grepl("M63", condition), "M63_0.4", NA)))) %>%
  dplyr::arrange(start) %>%
  dplyr::mutate(alt_id = paste0("HT_Storz_", row_number())) %>%
  dplyr::select(name, start, stop, strand, orientation, condition, technology, source, alt_id)
```

#### Yan data

* HT-inferred TSSs from PacBio long read data.
* Get PacBio TUs from the Yan paper ([reference](10.1038/s41467-018-05997-6))
* Files downloaded from [here](https://drive.google.com/drive/folders/156UQL5wUEPbAIKeSDtVoVml0vG4m4j8T?usp=sharing)


```{r pacbio-tss}
M9_definedEnd <- read.table("TU/HT/M9_RegulonDB_TU_definedEnd", stringsAsFactors = F)
M9_longestRead <- read.table("TU/HT/M9_RegulonDB_TU_longestRead", stringsAsFactors = F)
Rich_definedEnd <- read.table("TU/HT/Rich_RegulonDB_TU_definedEnd", stringsAsFactors = F)
Rich_longestRead <- read.table("TU/HT/Rich_RegulonDB_TU_longestRead", stringsAsFactors = F)

ht_pacbio_tss <- rbind.data.frame(M9_definedEnd, M9_longestRead, Rich_definedEnd, Rich_longestRead) %>%
  dplyr::rename(name = V8, start = V1, stop = V2, strand = V3, condition = V4) %>%
  dplyr::mutate(pos_1 = ifelse(strand == "-", stop, start)) %>%
  dplyr::select(-start, -stop, -contains("V")) %>%
  dplyr::mutate(start = pos_1, stop = pos_1, orientation = "", technology = "HT", source = "Yan") %>%
  dplyr::select(-pos_1) %>%
  dplyr::distinct() %>%
  dplyr::arrange(start) %>%
  dplyr::mutate(alt_id = paste0("HT_Yan_", row_number())) %>%
  dplyr::select(name, start, stop, strand, orientation, condition, technology, source, alt_id)

```

#### Palsson data

<!-- * [2012 paper](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3415461/) -->
* [2014 paper](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3923258/)
* Genome coordinates were converted from version U00096.2 to version U00096.3 [here](https://biocyc.org/ECOLI/map-seq-coords-form?chromosome=COLI-K12) 


```{r pallson-tss}
ht_palsson_tss <- read.delim("TSS/HT/pallson/Palsson_2014_converted.tsv", sep = "\t", header = TRUE, stringsAsFactors = F) %>%
  dplyr::select(-TSS.reads, -Sequence..50.nt.upstream...TSS..51.nt.) %>%
  tidyr::separate_rows(Conditions, sep = "") %>%
  dplyr::filter(!Conditions == "") %>%
  dplyr::mutate(name = NA, start = TSS.position, stop = TSS.position, strand = Strand, orientation = NA, technology = "HT", source = "Palsson") %>%
  dplyr::mutate(alt_id = paste0("HT_Palsson_", row_number())) %>%
  dplyr::mutate(condition = ifelse(Conditions == "E", "exponential_phase", 
                                   ifelse(Conditions == "G", "glutamine_nitrogen", 
                                          ifelse(Conditions == "H", "heat_shock", 
                                                 ifelse(Conditions == "S", "stationary_phase", NA))))) %>%
  dplyr::select(name, start, stop, strand, orientation, condition, technology, source, alt_id)
```

### Predictions (Huerta et al., 2003)

* Get set of predicted TSSs from RegulonDB ([Reference](https://doi.org/10.1016/j.jmb.2003.07.017))
* Files downloaded from the [RegulonDB website](http://regulondb.ccg.unam.mx/) on 2021/03/19.

**This set is not included**

```{r pred}
p24 <- read.delim("TSS/predictions/PromoterPredictionSigma24Set_up.txt", comment.char = ";", header = F)
p28 <- read.delim("TSS/predictions/PromoterPredictionSigma28Set_up.txt", comment.char = ";", header = F)
p32 <- read.delim("TSS/predictions/PromoterPredictionSigma32Set_up.txt", comment.char = ";", header = F)
p38 <- read.delim("TSS/predictions/PromoterPredictionSigma38Set_up.txt", comment.char = ";", header = F)
p54 <- read.delim("TSS/predictions/PromoterPredictionSigma54Set_up.txt", comment.char = ";", header = F)
p70 <- read.delim("TSS/predictions/PromoterPredictionSigma70Set_up.txt", comment.char = ";", header = F)

pred_all <- rbind.data.frame(p24, p28, p32, p38, p54, p70)

colnames(pred_all) <- c("leftpos", "rightpos", "strand", "gene", "name", 
                        "sigma", "-35Box_left", "-35Box_right", "-35Box", "spacer", 
                        "-10Box_left", "-10Box_right", "-10Box", "Pos_1", "score", 
                        "Homology_Level", "P-value", "Signicance_Level", "Evidence", "EvidenceType", "Sequence")

predicted_tss <- pred_all %>% 
  dplyr::mutate(start = Pos_1, stop = Pos_1) %>%
  dplyr::arrange(start) %>%
  dplyr::mutate(alt_id = paste0("pred_", row_number())) %>%
  dplyr::mutate(strand = ifelse(strand == "R", "-", ifelse(strand == "F", "+",NA))) %>%
  dplyr::mutate(technology = "prediction", source = "Collado", condition = sigma, orientation = NA) %>%
  dplyr::select(name, start, stop, strand, orientation, condition, technology, source, alt_id)
```

### Classic experiments

#### RegulonDB 

* Built from the `PromoterSet.txt` file downloaded from RegulonDB [website](http://regulondb.ccg.unam.mx/menu/download/datasets/files/PromoterSet.txt) (version 10.8)
* HT data is removed (to be used as an independent set)
* Predicted TSSs are removed
* Weak-evidence TSSs are removed

```{r exp}
## Get experimental promoters
exp_all <- read.delim("~/Desktop/Data/RegulonDB/downloaded/PromoterSet_10.8.txt", comment.char = "#", header = F)
colnames(exp_all) <- c("id", "name", "strand", "pos_1", "sigma", "sequence", "evidence", "confidence")

## Removing HT and predicted promoters from the "experimental" dataset
evidence_to_remove <- c("[ICWHO|W|Inferred computationally without human oversight],[RS-EPT-CBR|S|RNA-seq using two enrichment strategies for primary transcripts and consistent biological replicates]",
                        "[RS-EPT-CBR|S|RNA-seq using two enrichment strategies for primary transcripts and consistent biological replicates],[ICWHO|W|Inferred computationally without human oversight]",
                        "[RS-EPT-CBR|S|RNA-seq using two enrichment strategies for primary transcripts and consistent biological replicates]",
                        "[ICWHO|W|Inferred computationally without human oversight]")

exp_filtered <- exp_all %>% 
  dplyr::filter(!evidence %in% evidence_to_remove) %>%
  dplyr::filter(confidence %in% c("Strong", "Confirmed"))

## Formatting
exp_formatted <- exp_filtered %>% 
  rowwise() %>%
  mutate(cond = concat_uniq2(gsub(" ", "", sigma, fixed = TRUE))) %>%
  mutate(cond = ifelse(cond %in% c("", "unknown"), NA, cond)) %>%
  mutate(strand = ifelse(strand == "reverse", "-", ifelse(strand == "forward", "+",NA)),
         start = ifelse(pos_1 == 0, NA, pos_1),
         stop = ifelse(pos_1 == 0, NA, pos_1),
         condition = cond,
         technology = "classic",
         source = "RegulonDB",
         orientation = NA,
         alt_id = id) %>%
  dplyr::arrange(start) %>%
  dplyr::select(name, start, stop, strand, orientation, condition, technology, source, alt_id)

```

## TSS set

* TSSs are merged into single entries based on "start_stop_strand" duplicates. 

<!-- * A count column is created in order to keep track of the number of TSSs merged into each entry. -->

```{r merge}
## Merge all TSSs 
all_tss <- rbind.data.frame(ht_wade_tss, ht_morett_tss, ht_storz_tss, ht_pacbio_tss, ht_palsson_tss, exp_formatted)  %>%
  dplyr::mutate(coords = paste(start, stop, strand)) %>%
  mutate_all(na_if,"") %>%
  mutate(HT = ifelse(technology == "HT", 1, 0),
         classic = ifelse(technology == "classic", 1, 0),
         prediction = ifelse(technology == "prediction", 1, 0)
         ) 
  # dplyr::select(-technology) %>% 
  # ## Remove coordinates-less TSSs
  # dplyr::filter(!is.na(start)&!is.na(stop)) %>% 
  # dplyr::arrange(coords, name, condition)

## get sources and conditions for laterr graphics purpose
## reversing order cause of Wade's NA conditions
tss_sources = rev(unique(all_tss$source))
tss_conditions = rev(unique(all_tss$condition))


## Temporarily separate na coordinates to not have them merged
# tss_sourced_no_na <- tss_sourced %>% filter(!is.na(start)&!is.na(stop)) %>%
#   mutate_all(na_if,"") %>%
#   dplyr::arrange(coords, name, condition)

# tss_sourced_solo_na <- tss_sourced %>% 
#   filter(is.na(start)|is.na(stop)) %>%
#   mutate(count = 1)

## merge duplicate coordinates+strand
query <- "select 
  group_concat(distinct name) as name,
  min(start) as start,
  min(stop) as stop,
  min(strand) as strand,
  group_concat(distinct technology) as technology,
  group_concat(distinct source) as source,
  group_concat(distinct condition) as condition,
  group_concat(distinct orientation) as orientation,
  group_concat(alt_id) as alt_id,
  coords,
  max(HT) as HT,
  max(classic) as classic,
  max(prediction) as prediction,
  count(alt_id) as count
from all_tss 
group by coords
order by start"
 
tss_merged <- sqldf(query)

## Create TSS set to be written out
## Create Custom ID and write to file
## Remove coordless TSSs
## Add a ccolumn for the type of feature
## Select columns of interest
tss_set <- tss_merged %>%
  dplyr::mutate(tss_id = paste0("CTSS", row_number()),
                type = "TSS") %>%
  dplyr::filter(!is.na(start)) %>%
  dplyr::select(tss_id, start, stop, strand, name, source, condition, HT, classic, prediction, orientation, type, alt_id)

write.table(tss_set, file = tss_set_file, col.names = T,  row.names = F, quote = F, sep = "\t")

# Create separate ID-mapping table ## used elsewhere? shouldnt

# tss_id_mapping <- tss_set %>%
#   tidyr::separate_rows(alt_id, sep = ",") %>%
#   dplyr::select(tss_id, alt_id)
# 
# write.table(tss_id_mapping, file = tss_mapping_id_file, col.names = T,  row.names = F, quote = F, sep = "\t")
```

## Promoter set

Defined by TSSs merged using a 5bp-sliding window.

NB: coordinates-less TSSs are removed.

![Promoter definition](img/Promoter_definition.png){width=70%}


```{r promoter-by-window}
promoters_by_window <- tss_set %>%
  dplyr::arrange(start) %>%
  # dplyr::filter(!is.na(start)&!is.na(stop)) %>%
  group_by(grp = cumsum(start - lag(start, default = first(start)) > 4), strand) %>%
  summarise(tss_id = concat_uniq(tss_id),
           alt_id = concat_uniq(alt_id),
           start = min(start),
           stop = max(stop),
           # alt_count = sum(count),
           count = n(),
           HT = sum(HT),
           classic = sum(classic),
           prediction = sum(prediction),
           orientation = concat_uniq(orientation),
           condition = concat_uniq(condition),
           source = concat_uniq(source)
          ) %>%
  ungroup() %>%
  select(-grp) %>%
  mutate(promoter_id = paste0("CPROM", row_number()),
         type = "Promoter") %>%
  rowwise() %>%
  mutate(width = stop-start+1,
         coords = paste0(start, "_", stop))

promoter_set <- promoters_by_window %>% 
  select(promoter_id, start, stop, strand, type) 

write.table(promoter_set, file = promoter_set_file, col.names = T,  row.names = F, quote = F, sep = "\t")

```

## TSS-promoter mapping

```{r tss-prom-mapp}
tss_promoter_map <- promoters_by_window %>%
  dplyr::select(promoter_id, tss_id) %>%
  tidyr::separate_rows(tss_id, sep = ",")

write.table(tss_promoter_map, file = tss_promoter_map_file, col.names = T,  row.names = F, quote = F, sep = "\t")

```

## Summary

TSSs without filtering: `r nrow(all_tss)`

TSSs after duplicate merging: `r nrow(tss_set)`

Promoters: `r nrow(promoter_set)`

### TSSs stats

```{r fig-stats-tss-1, eval = TRUE}
tss_by_sources <- list()
for(s in tss_sources){
  tss_by_sources[[s]] <-(all_tss %>% filter(source == s) %>% select(alt_id))$alt_id
}

upset(fromList(tss_by_sources), nsets = length(tss_sources), number.angles = 30, point.size = 3.5, line.size = 2, 
    mainbar.y.label = "Intersections size", sets.x.label = "Number of TSSs per dataset", 
    text.scale = c(1.7, 1.7, 1.7, 1.7, 2, 1.7), order.by = "degree")
```

#### TSSs merged by coordinates between sources

```{r fig-stats-tss-2, , eval = TRUE}
tss_positions <- list()
for(s in tss_sources){
  tss_positions[[s]] <- (all_tss %>% filter(source == s) %>% select(coords))$coords
}

upset(fromList(tss_positions), nsets = length(tss_sources), nintersects = 100, number.angles = 30, point.size = 3.5, line.size = 2, 
			mainbar.y.label = "Intersections size", sets.x.label = "Number of TUs per dataset", 
			text.scale = c(1.5, 1.5, 1.5, 1.5, 2, 1.6), order.by = c("degree"))

```

#### TSSs merged by coordinates within sources

```{r fig-stats-tss-3, eval = TRUE, fig.height = 10}
tss_merging_within <- all_tss %>%
	dplyr::group_by(source, coords) %>%
	dplyr::summarise(count = n()) 

tss_source_plots <- list()
for(s in tss_sources) {
  gg <- ggplot(tss_merging_within %>% filter(source == s), aes(count)) + 
	geom_bar() + 
	scale_x_continuous(limits=c(0.5,10), breaks = 1:12) +
	# scale_y_continuous(limits=c(0,15), breaks = seq(0,15,5))  +
  ylab("Number of TSSs") +
  xlab("Duplication factor") +
  ggtitle(s)
  tss_source_plots[[s]] <- gg
}
do.call("grid.arrange", c(tss_source_plots, nrow = length(tss_sources)))

```

### Promoter stats

Promoters were built using a 5-bp-sliding window to group close by TSSs.

```{r stats-tss-3t}
ggplot(promoters_by_window, aes(x = width)) + 
  geom_bar() + 
  theme(text = element_text(size = 14)) +
  xlab("Promoter length") +
  ylab("Number of TSSs") +
  scale_y_log10() 

avg_tss_per_prom <- round(mean(promoters_by_window$count, na.rm = T), 2)
avg_prom_size <- round(mean(promoters_by_window$width, na.rm = T), 2)
```

* Average number of TSSs per promoter: `r avg_tss_per_prom`
* Average promoter size (nt): `r avg_prom_size`

#### TSSs merged by sliding window between sources

```{r fig-stats-tss-4, eval = TRUE}
promoters_by_source <- promoters_by_window %>%
  tidyr::separate_rows(source, sep = ",")

prom_list <- list()
for(s in tss_sources){
  prom_list[[s]] <- (promoters_by_source %>% filter(source == s) %>% select(promoter_id))$promoter_id
}

upset(fromList(prom_list), nsets = length(tss_sources), nintersects = 100, number.angles = 30, point.size = 3.5, line.size = 2, 
    mainbar.y.label = "Intersections size", sets.x.label = "Number of TSSs per dataset", 
    text.scale = c(1.5, 1.5, 1.5, 1.5, 2, 1.6), order.by = "degree")

```

#### TSSs merged by sliding window within sources

```{r fig-stats-tss-5, eval = TRUE, fig.height = 10}

promoter_merging_within <- promoters_by_source %>%
	dplyr::group_by(source, coords) %>%
	dplyr::summarise(count = n()) 

promoter_source_plots <- list()
for(s in tss_sources) {
  gg <- ggplot(promoter_merging_within %>% filter(source == s), aes(count)) + 
	geom_bar() + 
	scale_x_continuous(limits=c(0.5,10), breaks = 1:12) +
	# scale_y_continuous(limits=c(0,15), breaks = seq(0,15,5))  +
  ylab("Number of TSSs") +
  xlab("Merging factor") +
  ggtitle(s)
  promoter_source_plots[[s]] <- gg
}
do.call("grid.arrange", c(promoter_source_plots, nrow = length(tss_sources)))
```


```{r stats-prom, eval = FALSE}
promoter_composition <- promoters_by_window %>%
  dplyr::select(-source, -condition, -orientation, -tss_id) %>%
  tidyr::separate_rows(alt_id, sep = ",") %>%
  # left_join(tss_id_mapping, by = "alt_id") %>%
  left_join(all_tss %>% select(alt_id, start, source, condition, name), by ="alt_id") %>%
  rename(promoter_start = start.x,
         promoter_stop = stop,
         tss_position = start.y) %>%
  arrange(desc(width)) %>%
  filter(width >= 5)

source_palette <- random_palette(length(tss_sources))
condition_palette <- random_palette(length(tss_conditions))    

promoter_composition$source <- factor(promoter_composition$source, levels = tss_sources)
promoter_composition$condition <- factor(promoter_composition$condition, levels = tss_conditions)


pl <- list()
for(p in unique(promoter_composition$promoter_id)) {
  # p <- "CP11393"
  data <- promoter_composition %>% filter(promoter_id == p)
  name <- unique(data$name)
  width <- unique(data$width)
  promoter_start <- unique(data$promoter_start)
  promoter_stop <- unique(data$promoter_stop)
  gg <- ggplot(data, aes(x = tss_position, fill = source)) + 
    geom_dotplot(method = "histodot", binwidth = 1, stackgroups = T, stroke = 1, dotsize = 1, width = 1) +
    scale_y_continuous(NULL, breaks = NULL) +
    # scale_y_continuous(limits = c(0, 15), breaks = pretty_breaks(n = 5)) +
    scale_x_continuous(limits = c(promoter_start, promoter_start + max(promoter_composition$width)), breaks = pretty_breaks(n = 10)) +
    labs(title = paste0("Promoter name: ", name), subtitle = paste0("Width = ", width)) +
    theme(text = element_text(size = 10)) +
    scale_fill_manual(values = source_palette, drop = F, na.value = "#ffffff")
  hh <- ggplot(data, aes(x = tss_position, fill = condition)) + 
    geom_dotplot(method = "histodot", binwidth = 1, stackgroups = T, stroke = 1, dotsize = 1, width = 1) +
    scale_y_continuous(NULL, breaks = NULL) +
    # scale_y_continuous(limits = c(0, 15), breaks = pretty_breaks(n = 5)) +
    scale_x_continuous(limits = c(promoter_start, promoter_start + max(promoter_composition$width)), breaks = pretty_breaks(n = 10)) +
    labs(title = paste0("Promoter name: ", name), subtitle = paste0("Width = ", width)) +
    theme(text = element_text(size = 10)) +
    scale_fill_manual(values = condition_palette, drop = F, na.value = "#ffffff")
  # ggarrange(gg, hh, nrow = 2)
  pl[[p]] <- patchwork::wrap_elements(gg / hh) 
  # pl[[p]] <- hh
}

pdf("promoter_composition.pdf", width = 10)
for(p in unique(promoter_composition$promoter_id)) {
    print(pl[[p]])
}
dev.off()

```

<!-- ```{r stats-prom-classic} -->
<!-- ## classic promoters -->
<!-- classic_promoters_by_window <- tss_set %>% -->
<!--   dplyr::filter(classic == 1) %>% -->
<!--   dplyr::arrange(start) %>% -->
<!--   dplyr::filter(!is.na(start)&!is.na(stop)) %>% -->
<!--   group_by(grp = cumsum(start - lag(start, default = first(start)) > 4), strand) %>% -->
<!--   summarise(tss_id = concat_uniq(tss_id), -->
<!--            alt_id = concat_uniq(alt_id), -->
<!--            start = min(start), -->
<!--            stop = max(stop), -->
<!--            alt_count = sum(count), -->
<!--            count = n(), -->
<!--            classic = sum(classic), -->
<!--            orientation = concat_uniq(orientation), -->
<!--            condition = concat_uniq(condition) -->
<!--            ) %>% -->
<!--   ungroup() %>% -->
<!--   select(-grp) %>% -->
<!--   mutate(promoter_id = paste0("CCP", row_number())) %>% -->
<!--   rowwise() %>% -->
<!--   mutate(width = stop-start+1, -->
<!--          coords = paste0(start, "_", stop)) -->

<!-- ggplot(classic_promoters_by_window, aes(x = width)) +  -->
<!--   geom_bar() +  -->
<!--   theme(text = element_text(size = 14)) + -->
<!--   xlab("Promoter length") + -->
<!--   ylab("Number of TSSs") + -->
<!--   scale_y_log10() + -->
<!--   scale_x_continuous(limits=c(0.5,10), breaks = 1:10) -->



<!-- avg_tss_per_prom_classic <- round(mean(classic_promoters_by_window$count), 2) -->
<!-- avg_prom_size_classic <- round(mean(classic_promoters_by_window$width), 2) -->

<!-- ## -->
<!-- classic_promoter_composition <- classic_promoters_by_window %>% -->
<!--   dplyr::select(-condition, -orientation, -tss_id) %>% -->
<!--   tidyr::separate_rows(alt_id, sep = ",") %>% -->
<!--   left_join(tss_id_mapping, by = "alt_id") %>% -->
<!--   left_join(all_tss %>% select(alt_id, start, source, condition, name), by ="alt_id") %>% -->
<!--   rename(promoter_start = start.x, -->
<!--          promoter_stop = stop, -->
<!--          tss_position = start.y) %>% -->
<!--   arrange(desc(width)) %>% -->
<!--   filter(width >= 3) %>% -->
<!--   filter(grepl("ECK*", alt_id)) -->

<!-- source_palette <- random_palette(length(tss_sources)) -->
<!-- condition_palette <- random_palette(length(tss_conditions))     -->

<!-- classic_promoter_composition$source <- factor(classic_promoter_composition$source, levels = tss_sources) -->
<!-- classic_promoter_composition$condition <- factor(classic_promoter_composition$condition, levels = tss_conditions) -->


<!-- pl <- list() -->
<!-- for(p in unique(classic_promoter_composition$promoter_id)) { -->
<!--   # p <- "CP11393" -->
<!--   data <- classic_promoter_composition %>% filter(promoter_id == p) -->
<!--   name <- unique(data$name) -->
<!--   width <- unique(data$width) -->
<!--   promoter_start <- unique(data$promoter_start) -->
<!--   promoter_stop <- unique(data$promoter_stop) -->
<!--   gg <- ggplot(data, aes(x = tss_position, fill = source)) +  -->
<!--     geom_dotplot(method = "histodot", binwidth = 1, stackgroups = T, stroke = 1, dotsize = 1, width = 1) + -->
<!--     scale_y_continuous(NULL, breaks = NULL) + -->
<!--     # scale_y_continuous(limits = c(0, 15), breaks = pretty_breaks(n = 5)) + -->
<!--     scale_x_continuous(limits = c(promoter_start, promoter_start + max(classic_promoter_composition$width)), breaks = pretty_breaks(n = 10)) + -->
<!--     labs(title = paste0("Promoter name: ", name), subtitle = paste0("Width = ", width)) + -->
<!--     theme(text = element_text(size = 10)) + -->
<!--     scale_fill_manual(values = source_palette, drop = F, na.value = "#ffffff") -->
<!--   hh <- ggplot(data, aes(x = tss_position, fill = condition)) +  -->
<!--     geom_dotplot(method = "histodot", binwidth = 1, stackgroups = T, stroke = 1, dotsize = 1, width = 1) + -->
<!--     scale_y_continuous(NULL, breaks = NULL) + -->
<!--     # scale_y_continuous(limits = c(0, 15), breaks = pretty_breaks(n = 5)) + -->
<!--     scale_x_continuous(limits = c(promoter_start, promoter_start + max(classic_promoter_composition$width)), breaks = pretty_breaks(n = 10)) + -->
<!--     labs(title = paste0("Promoter name: ", name), subtitle = paste0("Width = ", width)) + -->
<!--     theme(text = element_text(size = 10)) + -->
<!--     scale_fill_manual(values = condition_palette, drop = F, na.value = "#ffffff") -->
<!--   # ggarrange(gg, hh, nrow = 2) -->
<!--   pl[[p]] <- patchwork::wrap_elements(gg / hh)  -->
<!--   # pl[[p]] <- hh -->
<!-- } -->

<!-- pdf("plots.pdf", width = 10) -->
<!-- for(p in unique(classic_promoter_composition$promoter_id)) { -->
<!--     print(pl[[p]]) -->
<!-- } -->
<!-- dev.off() -->
<!-- ``` -->

# Transcription units and co-transcribed genes

Transcription units are defined by their **unique coordinates and strand**. Experimental TUs are extracted from RegulonDB, HT TUs from a public dataset (Yan et al., 2018), and custom *orphan* TUs are made for remaining "orphans genes", or genes that are not entirely covered by any TU. They are then merged on the basis of their coordinates and strand.

Every group of co-transcribed genes (CTG) is made of **genes that are *entirely* co-transcribed together at least once**. The CTG set is derived from the TU set. TUs that contain exactly the same **complete** genes are grouped into a CTG sets, and the widest coordinates are kept. A given gene can be in several CTG sets, but 2 CTG sets cannot contain exactly the same genes. **Every gene** from Zika's genesView is present in **at least one CTG set.**

Both sets come with a "operon_name" column. Here, an operon is a set of adjacent genes made of *"one or several mutually overlapping transcription units that are transcribed in the same direction and share at least one gene"*, as proposed by Mejía-Almonte et al. (by Mejía-Almonte et al., 2020). It is purely informative, and may not match with known operons. 


![TU and CTG definition](img/TU_CTG_definition.png){width=90%}

Notes:

* Terminators have left and right positions, so the "largest" end is kept
* Operon names are made from overlapping CTGs that share at least one gene, they may differ from RegulonDB/Ecocyc operons. 

The following files and fields are created:

```{r create-filenames-tus}
## Creating file names
tu_set_file <- paste0(feature_set_dir, "/tu_set_", date, ".tsv")
ctg_set_file <- paste0(feature_set_dir, "/ctg_set_", date, ".tsv")
ctg_tu_map_file <- paste0(feature_set_dir, "/ctg_tu_map_", date, ".tsv")
ctg_gene_map_file <- paste0(feature_set_dir, "/ctg_gene_map_", date, ".tsv")

```

**`r tu_set_file`**

* **tu_id:** custom id (CTUxxx)
* **start:** left coordinate
* **stop:** right coordinate
* **strand:** "+" or "-"
* **source:** datasets from where it was collected
* **tu_name:** "valid" genes in tu (see definitions)
* **operon_name:** "valid" genes in operon (see definitions)
* **init_type:** one of "TSS", "HT TSS", "gene"
* **term_type:** one of "TTS", "HT TTS", "gene", "long"
* **reported_bnumbers:** TU genes reported by the source
* **valid_bnumbers:** TU genes that are entirely contained by the TU coordinates and IDed in Zika
* **flag_genes:** boolean, 1 if valid_bnumbers != reported_bnumbers, else 0
* **classic:** boolean, 1 if appears in classic TUs at least once, else 0
* **HT:** boolean, 1 if appears in HT TUs at least once, else 0
* **orphan:** boolean, 1 if TU is made of a gene that was not included in any of the previous TUs' valid bnumbers
* **type:** "TU"
* **alt_id:** id from source

**`r ctg_set_file`**

* **ctg_id:** custom id (CCTGxxx)
* **start:** left coordinate (widest)
* **stop:** right coordinate (widest)
* **strand:** "+" or "-"
* **reported_bnumbers:** TU genes reported by the source
* **valid_bnumbers:** TU genes that are entirely contained by the TU coordinates and IDed in Zika
* **type:** "CTG"

**`r ctg_tu_map_file`** 

* **ctg_id:** custom id (CCTGxxx)
* **tu_id:** custom id (CTUxxx)

**`r ctg_gene_map_file`** 

* **ctg_id:** custom id (CCTGxxx)
* **valid_bnumbers:** gene's "consensus bnumber" from the master gene table
* **rank:** position in CTG unit (strand-wise, excluding non-valid genes)
* **Zika_gene_id:** gene ID from Zika

## Sources 

### RegulonDB

* Get all TUs from RegulonDB by directly querying the database, with their associated promoter (if any), and first and last gene positions

```{r query-regulon}
## Get TUs from RegulonDB
regulondb_access <- dbConnect(RMariaDB::MariaDB(), 
											 username = regulondb_username,
                       password = regulondb_password,
                       dbname = regulondb_dbname,
                       host = regulondb_host,
                       port = regulondb_port)

## Part 1: get proms and genes associated to TUs from RegulonDB
query_1 <- "with TU_prom as (
		select transcription_unit_id,TU.promoter_id,TU.operon_id,P.pos_1 FROM TRANSCRIPTION_UNIT TU
		left join PROMOTER P
		on P.promoter_id = TU.promoter_id
    )
    , TU_gene_pos as (
		select TU.transcription_unit_id, 
			min(G.gene_strand) as tu_strand,
			#(case 
			#	when min(G.gene_strand) = 'forward' then min(G.gene_posleft)
			#	when min(G.gene_strand) = 'reverse' then max(G.gene_posright)
			#	else null
			#end) as tu_start,
			#(case 
			#	when min(G.gene_strand) = 'forward' then max(G.gene_posright)
			#	when min(G.gene_strand) = 'reverse' then min(G.gene_posleft)
			#	else null
			#end) as tu_end
      min(G.gene_posleft) as tu_gene_left,
			max(G.gene_posright) as tu_gene_right,
      group_concat(G.gene_name SEPARATOR ',') as alt_name,
      group_concat(G.gene_id SEPARATOR ',') as tu_gene_list
		from 
			(select gene_id,gene_name,gene_strand,gene_posleft,gene_posright from GENE) G,
			(select transcription_unit_id from TRANSCRIPTION_UNIT) TU,
			(select gene_id,transcription_unit_id from TU_GENE_LINK) LN
		where TU.transcription_unit_id = LN.transcription_unit_id
		and G.gene_id = LN.gene_id
		group by TU.transcription_unit_id
    )
    select TU.transcription_unit_id,
        TU.transcription_unit_name,
		TU_prom.promoter_id,
        TU_prom.pos_1,
        TU_gene_pos.tu_strand,	
        TU_gene_pos.tu_gene_left,
        TU_gene_pos.tu_gene_right,
        TU_gene_pos.alt_name,
        TU_gene_pos.tu_gene_list
	from TRANSCRIPTION_UNIT TU
    left join TU_prom
    on TU.transcription_unit_id = TU_prom.transcription_unit_id
    left join TU_gene_pos
    on TU.transcription_unit_id = TU_gene_pos.transcription_unit_id;
"

tus_with_prom_genes <- dbGetQuery(regulondb_access, query_1)

```

* Get terminators associated to TUs

NB: here I do not map terminators objects with TUs, only their position is used as a TU end coordinate

```{r query-regulon-2}
## Part 2: get terminators associated to promoters from RegulonDB
query_2 <- "select TU.transcription_unit_id,TR.terminator_id,TR.terminator_posleft,TR.terminator_posright 
    from
		(select terminator_id,terminator_posleft,terminator_posright from TERMINATOR) TR,
		(select transcription_unit_id from TRANSCRIPTION_UNIT) TU,
		(select transcription_unit_id,terminator_id from TU_TERMINATOR_LINK) LN
	where TU.transcription_unit_id = LN.transcription_unit_id
	and LN.terminator_id = TR.terminator_id;"

tus_with_term <- dbGetQuery(regulondb_access, query_2)

dbDisconnect(regulondb_access)

```

* Merge experimental TUs, promoters, terminator and gene coordinates

  * get the promoter position as start position if available, otherwise first position of the first gene in the TU (add flags)
  * get the terminator position as end position if available, otherwise last position of the last gene in the TU (add flags)
  * it is worth noting that some TUs (not operons) are associated with distinct terminators, which causes some redundancy
  * a few genes that are associated to a TU in RegulonDB don't have coordinates, so the master gene file is used to get them

```{r merge-exp-tus}
## join
tus_prom_genes_term <- dplyr::full_join(tus_with_prom_genes, tus_with_term, by = "transcription_unit_id") %>%
	mutate(terminator_unique_pos  = ifelse(tu_strand=="forward",terminator_posright,ifelse(tu_strand=="reverse",terminator_posleft,NA))) 

## format
tus_prom_genes_term_format <- tus_prom_genes_term %>%
	dplyr::mutate(chromosome = "NC_000913.3") %>%
	dplyr::mutate(tu_region_left = ifelse(tu_strand=="forward", 
																 ifelse(!is.na(pos_1), pos_1, tu_gene_left),
													ifelse(tu_strand=="reverse", 
																 ifelse(!is.na(terminator_unique_pos), terminator_unique_pos, tu_gene_left), NA))) %>%
	dplyr::mutate(tu_region_right = ifelse(tu_strand=="forward",
																	ifelse(!is.na(terminator_unique_pos), terminator_unique_pos, tu_gene_right),
													 ifelse(tu_strand=="reverse",
													 			 ifelse(!is.na(pos_1), pos_1, tu_gene_right),NA))) %>%
	dplyr::mutate(init_type = ifelse(!is.na(pos_1), "TSS", "gene")) %>%
	dplyr::mutate(term_type = ifelse(!is.na(terminator_unique_pos), "TTS", "gene")) %>%  
  dplyr::mutate(tu_strand = ifelse(tu_strand %in% c("reverse","-","R"), "-", ifelse(tu_strand %in% c("forward", "+", "F"), "+",NA))) %>%
  dplyr::arrange(tu_region_left) %>% 
  # dplyr::filter(!is.na(tu_region_left) | !is.na(tu_region_right)) %>%
	mutate(name = alt_name)

gene_bnumbers <- tus_prom_genes_term_format %>% 
  dplyr::select(tu_gene_list, tu_strand) %>%
	dplyr::mutate(id = seq.int(nrow(tus_prom_genes_term_format))) %>%
	tidyr::separate_rows(tu_gene_list) %>%
	dplyr::mutate(reported_bnumbers = EcoliGenes::get_gene_bnumber(tu_gene_list)) %>%
	dplyr::mutate(reported_genes = EcoliGenes::get_gene_symbol(reported_bnumbers)) %>%
	dplyr::mutate(start = EcoliGenes::get_gene_start(reported_bnumbers)) %>%
	# dplyr::mutate(strand = EcoliGenes::get_gene_strand(bnumber)) %>%
	dplyr::arrange(start) %>%
	# dplyr::mutate(genes = forcats::as_factor(genes)) %>%
	# dplyr::mutate(bnumber = forcats::as_factor(bnumber)) %>%
	dplyr::group_by(id) %>%
	dplyr::summarise(strand = concat_uniq(tu_strand),
	                 reported_genes = ifelse(strand == "-", concat_uniq(rev(reported_genes)), concat_uniq(reported_genes)),
	                 reported_bnumbers = ifelse(strand == "-", concat_uniq(rev(reported_bnumbers)), concat_uniq(reported_bnumbers))
	                 )

## Get coordinates for a few TUs from regulonDB, using master gene file (they're all single genes so tu_name == gene_name, in those cases)
tus_prom_genes_term_format_coords <- cbind.data.frame(tus_prom_genes_term_format, gene_bnumbers) %>% 
	rowwise()  %>%
	mutate(strand = ifelse(is.na(tu_strand), EcoliGenes::get_gene_strand(reported_bnumbers), tu_strand),
				 start = ifelse(is.na(tu_region_left), EcoliGenes::get_gene_start(reported_bnumbers), tu_region_left),
				 stop = ifelse(is.na(tu_region_right), EcoliGenes::get_gene_stop(reported_bnumbers), tu_region_right)
				 ) %>%
	ungroup()  %>%
	dplyr::mutate(alt_id = paste0(transcription_unit_id, "_", promoter_id, "_", terminator_id))

## Select columns of interest
exp_tus <- tus_prom_genes_term_format_coords %>%
  dplyr::mutate(source = "RegulonDB") %>%
	dplyr::select(alt_id, start, stop, strand, source, promoter_id, init_type, term_type, reported_genes, reported_bnumbers)
  # as.data.frame()  %>%
  # rowwise() %>%
  # dplyr::mutate(valid_bnumbers = EcoliGenes::what_genes(start, stop, strand))

# write.table(exp_tus, file = "TEMP_valid_genes.tsv", col.names = T, row.names = F, quote = F, sep = "\t")
```

### PacBio (HT)

* Get PacBio TUs from the Yan paper ([reference](10.1038/s41467-018-05997-6))
* Files provided by Victor: [link](https://drive.google.com/drive/folders/156UQL5wUEPbAIKeSDtVoVml0vG4m4j8T?usp=sharing)

* A few bnumbers have to be updated to new ones (using master gene file):
  * Old: b0255,b0257,b1016,b1017,b1416,b1417,b1509,b1510,b2031,b2090,b2138,b2999,b3000,b3767,b3768,b4540
  * New: b2139,b4488,b4490,b4493,b4498,b4571,b4587,b4658,b4696
* This may change artificially the number and order of genes in those TUs. For example, the TU "b1417,b1416" becomes "b4493". 

* Custom IDs are created for PacBIO TUs as follows: PB_GC_TUdefinition_XXX
	* GC: Growth condition (M9 or Rich)
	* TUdefinition: method to get TU boundaries: TU is defined by either a defined TSS and TTS pair (definedEnd) or the longest read from a defined TSS (longestRead).

```{r pacbio}
M9_definedEnd <- read.table("TU/HT/M9_RegulonDB_TU_definedEnd", stringsAsFactors = F)
M9_longestRead <- read.table("TU/HT/M9_RegulonDB_TU_longestRead", stringsAsFactors = F)
Rich_definedEnd <- read.table("TU/HT/Rich_RegulonDB_TU_definedEnd", stringsAsFactors = F)
Rich_longestRead <- read.table("TU/HT/Rich_RegulonDB_TU_longestRead", stringsAsFactors = F)

M9_definedEnd_format <- M9_definedEnd %>%
  dplyr::mutate(alt_id = paste0("PB_M9_definedEnd_", seq.int(nrow(M9_definedEnd)))) %>% 
  dplyr::mutate(source = "PB_M9_definedEnd") %>%
  dplyr::mutate(genes = V8, start = V1, stop = V2, strand = V3) %>%
  dplyr::select("alt_id", "genes", "start", "stop", "strand", source) 

M9_longestRead_format <- M9_longestRead %>%
  dplyr::mutate(alt_id = paste0("PB_M9_longestRead_", seq.int(nrow(M9_longestRead)))) %>% 
  dplyr::mutate(source = "PB_M9_longestRead") %>%
  dplyr::mutate(genes = V8, start = V1, stop = V2, strand = V3) %>%
  dplyr::select("alt_id", "genes", "start", "stop", "strand", source) 

Rich_definedEnd_format <- Rich_definedEnd %>%
  dplyr::mutate(alt_id = paste0("PB_Rich_definedEnd_", seq.int(nrow(Rich_definedEnd)))) %>% 
  dplyr::mutate(source = "PB_Rich_definedEnd") %>%
  dplyr::mutate(genes = V8, start = V1, stop = V2, strand = V3) %>%
  dplyr::select("alt_id", "genes", "start", "stop", "strand", source) 

Rich_longestRead_format <- Rich_longestRead %>%
  dplyr::mutate(alt_id = paste0("PB_Rich_longestRead_", seq.int(nrow(Rich_longestRead)))) %>% 
  dplyr::mutate(source = "PB_Rich_longestRead") %>%
  dplyr::mutate(genes = V8, start = V1, stop = V2, strand = V3) %>%
  dplyr::select("alt_id", "genes", "start", "stop", "strand", source) 


pacbio_tus <- rbind.data.frame(M9_definedEnd_format, M9_longestRead_format, Rich_definedEnd_format, Rich_longestRead_format) %>%
	mutate(init_type = "HT TSS") %>%
	mutate(term_type = ifelse(grepl("defined", alt_id), "HT TTS", "long"))  %>% 
	tidyr::separate_rows(genes, convert = TRUE) %>% 
	# group_by(alt_id) %>% 
	# mutate(rank = row_number()) %>%
	# ungroup() %>%
	dplyr::mutate(Consensus_bnumber = EcoliGenes::get_gene_bnumber(genes)) %>%
	dplyr::mutate(Consensus_symbol = EcoliGenes::get_gene_symbol(genes)) %>%
# pacbio_tus_genes <- pacbio_tus_genes_converted %>% 
	# mutate(Consensus_bnumber = forcats::as_factor(Consensus_bnumber),
	# 			 Consensus_symbol = forcats::as_factor(Consensus_symbol),
	# 			 genes = forcats::as_factor(genes)
	# 			 ) %>%
	# 			 genes = forcats::as_factor(genes)
	# 			 ) %>%
	group_by(alt_id) %>% 
	dplyr::summarise(across(where(is.character), concat_uniq),
	                 across(where(is.numeric), min)) %>%
	dplyr::mutate(reported_genes = Consensus_symbol) %>%
	dplyr::mutate(reported_bnumbers = Consensus_bnumber) %>%
 	dplyr::mutate(promoter_id = NA) %>%                                     ## (lack of) promoter added here
  dplyr::select(alt_id, start, stop, strand, source, promoter_id, init_type, term_type, reported_genes, reported_bnumbers) %>%
	arrange(start) 
#   rowwise() %>%
# 	# group_by(alt_id, Consensus_bnumber) %>%
#   mutate(valid_bnumbers = EcoliGenes::what_genes(start, stop, strand)) 


## Check how many genes are covered by longest that are not by defined

# genes_in_defined <- pacbio_tus %>%
#   dplyr::filter(grepl(pattern = "definedEnd", alt_id)) %>%
#   tidyr::separate_rows(bnumber, sep = ",") %>%
#   dplyr::select(bnumber) %>%
#   dplyr::distinct()
# 
# genes_in_longest <- pacbio_tus %>%
#   dplyr::filter(grepl(pattern = "longestRead", alt_id)) %>%
#   tidyr::separate_rows(bnumber, sep = ",") %>%
#   dplyr::select(bnumber) %>%
#   dplyr::distinct()
```

### Orphan TUs

* Get **valid genes** contained in TUs

  * Genes that are entirely contained by the TU boundaries
  * Genes that have a gene id in Zika (this excludes most phantom and pseudo genes, and a few small RNA-coding genes)

* Get genes that are not present and valid in a TU from RegulonDB or PacBio and make them "orphan TUs"
* Alternative IDs are created for orphan TUs as follows: orphan_XXX

```{r get-orphans}

exp_ht_tus <- rbind.data.frame(exp_tus, pacbio_tus)

## Get all consensus bnumber from Master table that are also in Zika
all_bnumbers_zika <- (master_gene_set %>% filter(!is.na(Zika_gene_id)))$Consensus_bnumber 

## Get "entire genes" in each TU
## meaning genes that are not cut and that are referenced in Zika (excl. phantom, pseudo y algunos small RNA)
exp_ht_tus_valid <- exp_ht_tus %>%
  tidyr::separate_rows(reported_bnumbers, sep = ",") %>% 
  dplyr::mutate(test1 = ifelse(EcoliGenes::get_gene_start(reported_bnumbers) >= start, T, F),
                  test2 = ifelse(EcoliGenes::get_gene_stop(reported_bnumbers) <= stop, T, F),
                  test3 = ifelse(reported_bnumbers %in% all_bnumbers_zika, T, F),
                  valid_bnumbers = ifelse(test1 & test2 & test3, reported_bnumbers, NA)) %>%
  dplyr::group_by(alt_id) %>%
	dplyr::summarise(across(where(is.character), concat_uniq),
	                 across(where(is.numeric), min)) 

# write.table(exp_ht_tus_valid, file = "TEMP_entire_genes.tsv", col.names = T, row.names = F, quote = F, sep = "\t")

## Get genes covered by RegulonDB and PacBio TUs
all_bnumbers_covered <- unique((exp_ht_tus_valid %>% tidyr::separate_rows(valid_bnumbers, sep = ","))$valid_bnumbers)

## Get Orphans
orphan_genes <- base::setdiff(all_bnumbers_zika, all_bnumbers_covered)

orphan_tus <- as.data.frame(orphan_genes) %>% 
	dplyr::left_join(master_gene_set, by = c("orphan_genes" = "Consensus_bnumber")) %>%
	dplyr::rename(reported_bnumbers = orphan_genes) %>%
	dplyr::mutate(valid_bnumbers = reported_bnumbers) %>%
	dplyr::mutate(reported_genes = EcoliGenes::get_gene_symbol(reported_bnumbers)) %>%
	dplyr::mutate(start = EcoliGenes::get_gene_start(reported_bnumbers)) %>%
	dplyr::mutate(stop = EcoliGenes::get_gene_stop(reported_bnumbers)) %>%
	dplyr::mutate(strand = EcoliGenes::get_gene_strand(reported_bnumbers)) %>%
	dplyr::mutate(alt_id = paste0("orphan_", row_number())) %>%
	dplyr::mutate(promoter_id = "") %>%                                              ## (lack of) promoter added here
  dplyr::mutate(init_type = "gene",
                term_type = "gene",
                source = "orphan") %>%
  dplyr::select(alt_id, start, stop, strand, source, promoter_id, init_type, term_type, reported_genes, reported_bnumbers, valid_bnumbers)

# write.table(orphan_tus, file = "TEMP_orphan.tsv", col.names = T, row.names = F, quote = F, sep = "\t")

```

## TU set creation

```{r merge-all-tus}
## join all TUs and add a few properties
all_tus <- rbind.data.frame(exp_ht_tus_valid, orphan_tus) %>%
  mutate(coords = paste0(start, "_", stop, "_", strand)) %>%
  rowwise() %>%
  mutate(classic = ifelse(grepl("ECK12*", alt_id), 1, 0),
         orphan = ifelse(grepl("orphan_*", alt_id), 1, 0),
         HT = ifelse(grepl("PB_*", alt_id), 1, 0)
         ) %>%
  ## make "start_stop_strand" column to filter out coord duplicates 
	mutate(coords = paste0(start, "_", stop, "_", strand)) %>%
  ## fill out blanks with NAs
  mutate_all(na_if,"") %>%
	dplyr::left_join(tss_set %>% select(alt_id, tss_id) %>% separate_rows(alt_id, sep = ","), c("promoter_id" = "alt_id")) %>%
	dplyr::select(-promoter_id) %>%
	# dplyr::rename(tss_id = custom_id) %>%
  dplyr::arrange(start) %>%
	tidyr::separate_rows(valid_bnumbers, sep= ",") %>%
  # dplyr::rowwise() %>%
	dplyr::mutate(
		valid_genes = EcoliGenes::get_gene_symbol(valid_bnumbers),
		gene_start = EcoliGenes::get_gene_start(valid_bnumbers)
		) %>%
	dplyr::arrange(alt_id, gene_start) %>%
	dplyr::group_by(alt_id) %>%
	dplyr::summarise(
		start = min(start),
		stop = min(stop),
		strand = concat_uniq(strand), 
		source = concat_uniq(source), 
		tu_name = ifelse(strand == "-", concat_uniq(rev(valid_genes), sep = "_"), concat_uniq(valid_genes, "_")),
		classic = mean(classic),
		orphan = mean(orphan),
		HT = mean(HT),
		reported_genes = concat_uniq(reported_genes),
		reported_bnumbers = concat_uniq(reported_bnumbers),
		valid_genes = ifelse(strand == "-", concat_uniq(rev(valid_genes)), concat_uniq(valid_genes)),
		valid_bnumbers = concat_uniq(valid_bnumbers),
		coords = concat_uniq(coords),
		tss_id = concat_uniq(tss_id),
		init_type = concat_uniq(init_type),
		term_type = concat_uniq(term_type)
		)

## Union TUs and genes to get operons
temp <- all_tus %>%
	mutate(tu_genes = tu_name) %>%
	mutate(tu_genes_2 = tu_name) %>%
	separate_rows(tu_genes, sep ="_") %>%
	separate_rows(tu_genes_2, sep = "_") 
relations <- data.frame(from = temp$tu_genes,to = temp$tu_genes_2)
g <- graph_from_data_frame(relations)
group_id <- data.frame(V = names(clusters(g)$membership),
                       operon = clusters(g)$membership, stringsAsFactors = FALSE)

table_gene_tu_operon <- temp %>% 
	dplyr::left_join(group_id, by = c("tu_genes" = "V")) %>% 
	dplyr::arrange(start) %>%
	dplyr::group_by(alt_id) %>%
	dplyr::summarise(strand = concat_uniq(strand), 
						tu_name = concat_uniq(tu_name),
						start = min(start), 
						stop = max(stop),
						operon = concat_uniq(operon)
						) %>%
	dplyr::group_by(operon) %>%
  dplyr::arrange(start) %>%
	dplyr::summarise(strand = concat_uniq(strand), 
						operon_name = concat_uniq(unlist(strsplit(tu_name, split = "_"))), 
						alt_id = concat_uniq(alt_id)
						) %>% 
	dplyr::select(-operon, -strand) %>%
	tidyr::separate_rows(alt_id, sep = ",") %>%
	dplyr::arrange(operon_name)


all_tus <- all_tus %>%
	dplyr::left_join(table_gene_tu_operon, by = c("alt_id" = "alt_id")) #%>%
#   dplyr::rowwise() %>%
#   dplyr::mutate(genic_start = EcoliGenes::is_genic(start-1, strand),
#                 genic_stop = EcoliGenes::is_genic(stop+1, strand)) 
# 
# write.table(all_tus_operons_added, file = "temp_all_tus_bf_sets.tsv", sep = "\t", quote = F, col.names = T, row.names = F)

```

* TUs are merged into single entries based on "start_stop_strand" duplicates

<!-- * A 'count' column is created in order to keep track of the number of TUs merged into each entry -->

```{r quit-dupli-coords}
## Eliminate duplicate coordinates
query <- "select 
  group_concat(distinct tu_name) as tu_name,
  min(start) as start,
  min(stop) as stop,
  min(strand) as strand,
  min(source) as source,
  max(`classic`) as 'classic',
  max(orphan) as orphan,
  max(HT) as HT,
  group_concat(distinct reported_genes) as reported_genes,
  group_concat(distinct reported_bnumbers) as reported_bnumbers,
  group_concat(distinct valid_genes) as valid_genes,
  group_concat(distinct valid_bnumbers) as valid_bnumbers,
  group_concat(distinct tss_id) as tss_id,
  group_concat(distinct alt_id) as alt_id,
  group_concat(distinct init_type) as init_type,
  group_concat(distinct term_type) as term_type,
  count(alt_id) as count,
  group_concat(distinct operon_name) as operon_name
from all_tus 
group by coords
order by start"
 
tu_set <- sqldf::sqldf(query)  %>%
  dplyr::mutate(tu_id = paste0("CTU", row_number())) %>%
	mutate_all(na_if,"") %>% 
  dplyr::mutate(flag_genes = ifelse(reported_bnumbers != valid_bnumbers, 1, 0),
                type = "TU") %>%
  dplyr::select(tu_id, start, stop, strand, tu_name, operon_name, init_type, term_type, reported_bnumbers, valid_bnumbers, 
                flag_genes, source, classic, HT, orphan, type, alt_id)

write.table(tu_set, file = tu_set_file, col.names = T,  row.names = F, quote = F, sep = "\t")

# write.table(tus_set_merged_ided, file = "temp_check_empty_by_genes.tsv", sep = "\t", quote = F, col.names = T, row.names = F)

```

<!-- ### TU-gene mapping  -->

<!-- * Generate a file that maps genes with TUs: -->

<!--   * RegulonDB has its own "TU-gene" table -->
<!--   * PacBio TUs come with their corresponding genes (genes covered by the TUs based on coordinates, a gene can be included if TU boundaries fall inside of it) -->

<!-- ```{r tu-gene_mapping} -->
<!-- zika_gene_id_mapping <- gene_set %>% select(Consensus_bnumber, Zika_gene_id) -->

<!-- tu_set_gene_mapping <- tus_set_merged_ided %>% -->
<!-- 	dplyr::select(tu_id, valid_bnumbers) %>% -->
<!-- 	tidyr::separate_rows(valid_bnumbers, sep = ",") %>% -->
<!-- 	dplyr::group_by(tu_id) %>% -->
<!-- 	dplyr::mutate(rank = row_number()) %>% -->
<!--   dplyr::left_join(zika_gene_id_mapping, by = c("valid_bnumbers" = "Consensus_bnumber")) %>% -->
<!--   dplyr::ungroup() -->

<!-- ``` -->

## Co-transcribed genes set

* TUs are merged into single entries based on *valid* gene content duplicates

```{r quit-dupli-genes}
## Eliminate duplicate gene content

query <- "select 
  group_concat(distinct tu_id) as tu_id,
  group_concat(distinct tu_name) as tu_name,
  min(start) as start,
  max(stop) as stop,
  group_concat(distinct strand) as strand,
  group_concat(distinct source) as source,
  max(`classic`) as 'classic',
  max(orphan) as orphan,
  max(HT) as HT,
  group_concat(distinct alt_id) as alt_id,
  count(alt_id) as count,
  group_concat(distinct reported_bnumbers) as reported_bnumbers,
  valid_bnumbers,
  group_concat(distinct operon_name) as operon_name
from tu_set 
group by valid_bnumbers
order by start"
 
ctg_set <- sqldf::sqldf(query) %>%
  dplyr::filter(!is.na(valid_bnumbers)) %>%
  dplyr::mutate(ctg_id = paste0("CCTG", row_number()),
                type = "CTG")  %>%
  dplyr::select(ctg_id, start, stop, strand, reported_bnumbers, valid_bnumbers, type, tu_id)

write.table(ctg_set %>% dplyr::select(-tu_id), file = ctg_set_file, col.names = T,  row.names = F, quote = F, sep = "\t")

```

* A table is created to map TUs with CTGs

```{r map-files}

ctg_gene_map <- ctg_set %>%
	dplyr::select(ctg_id, valid_bnumbers) %>%
	tidyr::separate_rows(valid_bnumbers, sep = ",") %>%
	dplyr::group_by(ctg_id) %>%
	dplyr::mutate(rank = row_number()) %>%
  dplyr::left_join(master_gene_set %>% select(Consensus_bnumber, Zika_gene_id), by = c("valid_bnumbers" = "Consensus_bnumber")) 

write.table(ctg_gene_map, file = ctg_gene_map_file, col.names = T,  row.names = F, quote = F, sep = "\t")


ctg_tu_map <- ctg_set %>%
	dplyr::select(ctg_id, tu_id) %>%
	tidyr::separate_rows(tu_id, sep = ",") 

write.table(ctg_tu_map, file = ctg_tu_map_file, col.names = T,  row.names = F, quote = F, sep = "\t")

```

## Summary

* Total TUs: `r nrow(all_tus)`

* Total TUs without duplicate coordinates: `r nrow(tu_set)`

* Total TUs without duplicate gene content (CTG set): `r nrow(ctg_set)` 

```{bash calculate-coverage, eval = FALSE}
bedtools genomecov -i tu_set_2021-08-06.bed -g NC_000913.3.genome -d > temp_coverage_coords.tsv
awk '{ total += $3 } END { print total/4641652 }' temp_coverage_coords.tsv 
3.52787
 
bedtools genomecov -i cotranscribed_genes_2021-08-06.bed -g NC_000913.3.genome -d > temp_coverage_genes.tsv
awk '{ total += $3 } END { print total/4641652 }' temp_coverage_genes.tsv 
1.78361
```

### All TUs

#### Sources

```{r fig-stats-tus-1, eval = TRUE}
tu_sources <- unique(tu_set$source)

tu_by_sources <- list()
for(s in tu_sources){
  tu_by_sources[[s]] <-(all_tus %>% filter(source == s) %>% select(alt_id))$alt_id
}

upset(fromList(tu_by_sources), nsets = length(tu_sources), number.angles = 30, point.size = 3.5, line.size = 2, 
    mainbar.y.label = "Intersections size", sets.x.label = "Number of TSSs per dataset", 
    text.scale = c(1.7, 1.7, 1.7, 1.7, 2, 1.7), order.by = "degree")
```


<!-- #### TUs containing at least 1 pseudo gene or phantom gene.  -->


<!-- ```{r fig-stats-tus-3, eval = TRUE} -->

<!-- tu_by_coords_flags <- all_tus_operons_added %>% -->
<!--   dplyr::mutate(Source = ifelse(grepl("ECK12*", alt_id), "RegulonDB",  -->
<!--                                 ifelse(grepl("PB_M9_definedEnd*", alt_id), "PB_M9_definedEnd", -->
<!--                                        ifelse(grepl("PB_M9_longestRead*", alt_id), "PB_M9_longestRead", -->
<!--                                               ifelse(grepl("PB_Rich_definedEnd*", alt_id), "PB_Rich_definedEnd", -->
<!--                                                      ifelse(grepl("PB_Rich_longestRead*", alt_id), "PB_Rich_longestRead", -->
<!--                                                             ifelse(grepl("orphan_*", alt_id), "Orphan",NA))))))) %>% -->
<!--   dplyr::select(Source, tu_name, start, stop, strand, pseudo, phantom) -->
<!--   # dplyr::select(Source, tu_name, start, stop, strand, pseudo, phantom, genic_start, genic_stop) -->


<!-- a1 <- ggplot(data = tu_by_coords_flags, aes(x = Source, y = pseudo)) + -->
<!--   geom_bar(stat="identity") + -->
<!--   theme(axis.text.x = element_text(angle = 30, vjust = 1, hjust = 1, size = 12)) + -->
<!--   labs(title = "Pseudo genes in TUs") + -->
<!--   ylab("Number of TUs") -->

<!-- a2 <- ggplot(data = tu_by_coords_flags, aes(x = Source, y = phantom)) + -->
<!--   geom_bar(stat="identity") + -->
<!--   theme(axis.text.x = element_text(angle = 30, vjust = 1, hjust = 1, size = 12)) + -->
<!--   labs(title = "Phantom genes in TUs") + -->
<!--   ylab("Number of TUs") -->


<!--  a1 / a2 -->
<!-- ``` -->


```{r stats-tus-4}

# tu_by_coords_flags_genic <- tu_by_coords_flags %>% dplyr::filter(genic_start != 0 | genic_stop !=0) %>%
#   dplyr::rowwise() %>%
#   dplyr::mutate(start_in_gene = ifelse(genic_start == 1, EcoliGenes::where_genic(start, strand), NA)) %>%
#   dplyr::mutate(start_in_gene_relative = ifelse(genic_start == 1, EcoliGenes::where_genic_rel(start, strand), NA)) %>%
#   dplyr::mutate(stop_in_gene = ifelse(genic_stop == 1, EcoliGenes::where_genic(stop, strand), NA)) %>%
#   dplyr::mutate(stop_in_gene_relative = ifelse(genic_stop == 1, EcoliGenes::where_genic_rel(stop, strand), NA)) 
# 
# write.table(tu_by_coords_flags_genic, file = "KEEP_tuc_genic_positions.tsv", sep = "\t", quote = F, row.names = F, col.names = T)
# # 
# ggplot(tu_by_coords_flags_genic, aes(x = start_in_gene_relative)) +
#     geom_histogram(position="identity", colour="grey40", alpha=0.2, bins = 10) +
#     facet_grid(. ~ Source)

```

#### Type of initiation and termination of TUs

Based on all collected TUs before any sort of merging.

```{r fig-stats-tus-init, eval = TRUE, fig.height = 8}
all_tus$source <- factor(all_tus$source, 
                               levels = c("RegulonDB", "PB_M9_definedEnd", "PB_Rich_definedEnd", "PB_M9_longestRead", "PB_Rich_longestRead", "Orphan"))
all_tus$init_type <- factor(all_tus$init_type, levels = c("TSS", "HT TSS", "gene"))
all_tus$term_type <- factor(all_tus$term_type, levels = c("TTS", "HT TTS", "gene", "long"))

g1 <- ggplot(all_tus, aes(x = init_type, fill = source)) + 
  geom_bar() +
  theme(text = element_text(size = 14),  legend.position = "none") +
  scale_fill_brewer(palette = "Dark2", drop = F) +
  xlab("Type of initiation coordinate") +
  ylab("Number of TUs")

g2  <- ggplot(all_tus, aes(x = term_type, fill = source)) + 
  geom_bar() +
  theme(text = element_text(size = 14),  legend.position = "bottom") +
  scale_fill_brewer(palette = "Dark2", drop = F) +
  xlab("Type of termination coordinate") +
  ylab("Number of TUs")

g1 / g2
```

### TU set

<!-- From 8,558 to 8,269 TUs: 289 TUs are "lost" -->

<!-- * 225 of them are PacBio TUs duplicated between both growth conditions M9 and Rich (blue) -->
<!-- * 43 are duplicated between the different conditions of the PacBio set (light blue and purple) -->
<!-- * 18 are duplicated inside of RegulonDB TU set (green) -->

#### Coordinates duplication between datasets

```{r fig-stats-tus-2, , eval = TRUE}
tu_positions <- list()
for(s in tu_sources){
  tu_positions[[s]] <- (all_tus %>% filter(source == s) %>% select(coords))$coords
}

upset(fromList(tu_positions), nsets = length(tu_sources), nintersects = 100, number.angles = 30, point.size = 3.5, line.size = 2, 
			mainbar.y.label = "Intersections size", sets.x.label = "Number of TUs per dataset", 
			text.scale = c(1.5, 1.5, 1.5, 1.5, 2, 1.6), order.by = c("degree"))

```

#### Coordinates duplication within datasets

NB: y axis is the number of TUs duplicated, x axis is the duplication factor

```{r fig-stats-tus-coords-each, eval = TRUE, fig.height = 10}

tu_merging_within <- all_tus %>%
	dplyr::group_by(source, coords) %>%
	dplyr::summarise(count = n()) 

tu_source_plots <- list()
for(s in tu_sources) {
  gg <- ggplot(tu_merging_within %>% filter(source == s), aes(count)) + 
	geom_bar() + 
	scale_x_continuous(limits=c(0.5,10), breaks = 1:12) +
	# scale_y_continuous(limits=c(0,15), breaks = seq(0,15,5))  +
  ylab("Number of TUs") +
  xlab("Duplication factor") +
  ggtitle(s)
  tu_source_plots[[s]] <- gg
}
do.call("grid.arrange", c(tu_source_plots, nrow = length(tu_sources)))

```

### CTG set

#### Gene content duplication between datasets
	
```{r fig-stats-tus-genes, eval = TRUE}

ctg_content <- list()
for(s in tu_sources){
  ctg_content[[s]] <- (all_tus %>% filter(source == s) %>% select(valid_bnumbers))$valid_bnumbers
}

upset(fromList(ctg_content), nsets = length(tu_sources), nintersects = 100, number.angles = 30, point.size = 3.5, line.size = 2, 
			mainbar.y.label = "Intersections size", sets.x.label = "Number of TUs per dataset", 
			text.scale = c(1.5, 1.5, 1.5, 1.5, 2, 1.6), order.by = c("degree"))

# 
# cotranscribed_genes_stats <- tu_set_by_source %>%
# 	dplyr::group_by(valid_bnumbers) %>%
# 	dplyr::summarise(across(where(is.factor), concat_uniq),
# 						across(where(is.character), concat_uniq),
# 						across(where(is.numeric), sum),
# 						across(where(is.logical), max)) %>%
# 	dplyr::rowwise() %>%
# 	dplyr::mutate(new_count = sum(Source_Orphan, Source_RegulonDB, Source_PacBio_M9_definedEnd, Source_PacBio_M9_longestRead, Source_PacBio_Rich_definedEnd, Source_PacBio_Rich_longestRead))
#  
# 
# l4 <- list(
#   PacBio_M9_definedEnd = (cotranscribed_genes_stats %>% filter(Source_PacBio_M9_definedEnd == 1) %>% select(valid_bnumbers))$valid_bnumbers,
#   PacBio_M9_longestRead = (cotranscribed_genes_stats %>% filter(Source_PacBio_M9_longestRead == 1) %>% select(valid_bnumbers))$valid_bnumbers,
#   PacBio_Rich_definedEnd = (cotranscribed_genes_stats %>% filter(Source_PacBio_Rich_definedEnd == 1) %>% select(valid_bnumbers))$valid_bnumbers,
#   PacBio_Rich_longestRead = (cotranscribed_genes_stats %>% filter(Source_PacBio_Rich_longestRead == 1) %>% select(valid_bnumbers))$valid_bnumbers,
#   RegulonDB = (cotranscribed_genes_stats %>% filter(Source_RegulonDB == 1) %>% select(valid_bnumbers))$valid_bnumbers,
#   Orphan = (cotranscribed_genes_stats %>% filter(Source_Orphan == 1) %>% select(valid_bnumbers))$valid_bnumbers
# )
# 
# upset(fromList(l4), nsets = 35, number.angles = 30, point.size = 3.5, line.size = 2, 
# 			mainbar.y.label = "Intersections size", sets.x.label = "Number of TUs per dataset", 
# 			# sets = c("PacBio_Rich_longestRead", "PacBio_M9_longestRead", "PacBio_Rich_definedEnd", "PacBio_M9_definedEnd"), 
# 			text.scale = c(1.5, 1.5, 1.5, 1.5, 2, 1.6), order.by = c("degree", "freq"))

```

#### Gene content duplication within datasets

<!-- 1419 are duplicated within datasets (some of which are included in the duplicates across datasets) -->

<!-- * RegulonDB TUs: some TUs are associated with 0, 1 or several promoters/terminators. This causes a given set of genes composing a TU to have several sets of coordinates (green) -->
<!-- 	* 966 TUs are merged into 391 (-575) -->

<!-- * Duplication inside of each PacBio set (light blue) is mostly due to the "longest read" method: -->
<!-- 	* 80 to 37 TUs (M9 definedEnd, -43) -->
<!-- 	* 703 to 293 TUs (M9 longestRead, -410) -->
<!-- 	* 84 to 38 TUs (Rich definedEnd, -46) -->
<!-- 	* 597 to 252 TUs (Rich longestRead, -345) -->
	
NB: y axis is the number of TUs duplicated, x axis is the duplication factor

```{r fig-stats-tus-genes-each, eval = TRUE, fig.height = 10}

tu_merging_within <- all_tus %>%
	dplyr::group_by(source, valid_bnumbers) %>%
	dplyr::summarise(count = n()) 

tu_source_plots <- list()
for(s in tu_sources) {
  gg <- ggplot(tu_merging_within %>% filter(source == s), aes(count)) + 
	geom_bar() + 
	scale_x_continuous(limits=c(0.5,10), breaks = 1:12) +
	# scale_y_continuous(limits=c(0,15), breaks = seq(0,15,5))  +
  ylab("Number of TUs") +
  xlab("Duplication factor") +
  ggtitle(s)
  tu_source_plots[[s]] <- gg
}
do.call("grid.arrange", c(tu_source_plots, nrow = length(tu_sources)))

# 
# q1 <- ggplot(cotranscribed_genes_stats %>% filter(Source_RegulonDB > 1), aes(Source_RegulonDB)) + 
# 	geom_bar() + 
# 	scale_x_continuous(limits=c(1.5,10), breaks = 1:10) +
#   xlab("Duplication factor") +
#   ylab("Number of TUs") +
#   ggtitle("RegulonDB")
# 
# q2 <- ggplot(cotranscribed_genes_stats %>% filter(Source_PacBio_M9_definedEnd > 1), aes(Source_PacBio_M9_definedEnd)) + 
# 	geom_bar() + 
# 	scale_x_continuous(limits=c(1.5,10), breaks = 1:10) +
#   xlab("Duplication factor") +
#   ylab("Number of TUs") +
#   ggtitle("PacBio_M9_definedEnd")
# 
# q3 <- ggplot(cotranscribed_genes_stats %>% filter(Source_PacBio_M9_longestRead > 1), aes(Source_PacBio_M9_longestRead)) + 
# 	geom_bar() + 
# 	scale_x_continuous(limits=c(1.5,10), breaks = 1:10) +
#   xlab("Duplication factor") +
#   ylab("Number of TUs") +
#   ggtitle("PacBio_M9_longestRead")
# 
# q4 <- ggplot(cotranscribed_genes_stats %>% filter(Source_PacBio_Rich_definedEnd > 1), aes(Source_PacBio_Rich_definedEnd)) + 
# 	geom_bar() + 
# 	scale_x_continuous(limits=c(1.5,10), breaks = 1:10) +
#   xlab("Duplication factor") +
#   ylab("Number of TUs") +
#   ggtitle("PacBio_Rich_definedEnd")
# 
# q5 <- ggplot(cotranscribed_genes_stats %>% filter(Source_PacBio_Rich_longestRead > 1), aes(Source_PacBio_Rich_longestRead)) + 
# 	geom_bar() + 
# 	scale_x_continuous(limits=c(1.5,10), breaks = 1:10) +
#   xlab("Duplication factor") +
#   ylab("Number of TUs") +
#   ggtitle("PacBio_Rich_longestRead")
# 
# q6 <- ggplot(cotranscribed_genes_stats %>% filter(Source_Orphan > 1), aes(Source_Orphan)) + 
# 	geom_bar() + 
# 	scale_x_continuous(limits=c(1.5,10), breaks = 1:10) +
#   xlab("Duplication factor") +
#   ylab("Number of TUs") +
#   ggtitle("Orphan")
# 
# q1 / q2 / q3 / q4 / q5 / q6
```



# Known binding sites

Based on **RegulonDB version 10.8**, downloaded [here](http://regulondb.ccg.unam.mx/menu/download/datasets/files/BindingSiteSet.txt).

Weak-evidence sites are removed.

The following files and fields are created:

```{r create-filenames-bs}

tfbs_set_file <- paste0(feature_set_dir, "/tfbs_set_", date, ".tsv")
# bs_set_bed_file <- paste0(feature_set_dir, "/bs_set_", date, ".bed")
# bs_mapping_id_file <- paste0(feature_set_dir, "/bs_id_mapping_", date, ".tsv")
# bs_tss_mapping_file <- paste0(feature_set_dir, "/bs_tss_mapping_", date, ".tsv")
# bs_tu_mapping_file <- paste0(feature_set_dir, "/bs_tu_mapping_", date, ".tsv")

```

`r tfbs_set_file`

* **tfbs_id:** custom id (CTFBSXXX)
* **start:** left position
* **stop:** right position
* **TF_name:** TF protein name
* **TF_bnumber:** consensus bnumber from the master table of the gene(s) coding the TF
* **effect:** repressor or activator
* **evidence:** type of evidence, experiment, prediction, etc
* **confidence:** depending on evidence, one of "Weak", "Strong" or "Confirmed"
* **type:** "TFBS"
* **alt_id:** id from source
* **Zika_gene_id:** gene id from Zika of the gene(s) coding the TF

```{r tfbs-load}
## load BindingSiteSet version 10.8
regu_bs <- read.delim("~/Desktop/Data/RegulonDB/downloaded/BindingSiteSet_10.8_210602.txt", comment.char = "#", header = F)
colnames(regu_bs) <- c("TF_id", "TF_name", "Conformation", "alt_id", "start", "stop", "strand", "tfg_interaction_id", "TU_alt_id", "TU_name", "effect", 
											 "Promoter_name", "relative_center_pos", "sequence", "distance_closest_gene", "evidence", "confidence")

# tss_name_id_map <- exp_formatted %>%
# 	dplyr::select(name, alt_id) %>%
# 	dplyr::rename(tss_alt_id = alt_id)
# 
# temp_bs_tu_mapping <- tu_set_id_mapping %>%
#   filter(grepl("ECK12", alt_id)) %>%
#   rowwise() %>%
#   mutate(regulondb_tu_id = unlist(strsplit(alt_id, split = "_"))[1])

## get TF bnum and symbol // heterodimers are broken into 2 sites associated to 2 distinct bnumbers
regu_bs_formatted <- regu_bs %>%
  dplyr::filter(confidence %in% c("Strong", "Confirmed")) %>%
	dplyr::mutate_all(na_if,"") %>%
	dplyr::mutate(TF_bnumber = EcoliGenes::get_tf_bnumber(TF_name)) %>%
	dplyr::mutate(TF_symbol = EcoliGenes::get_tf_symbol(TF_name)) %>%
	tidyr::separate_rows(TF_bnumber, convert = T, sep = ",") %>%
	dplyr::mutate(strand = ifelse(strand == "reverse", "-", ifelse(strand == "forward", "+", NA))) %>%
	# dplyr::left_join(temp_bs_tu_mapping, by = c("TU_alt_id" = "regulondb_tu_id")) %>%
	# # dplyr::rename(tu_id = custom_id) %>%
	# dplyr::left_join(tss_name_id_map, by = c("Promoter_name" = "name")) %>%
	# dplyr::left_join(tss_id_mapping, by = c("tss_alt_id" = "alt_id")) %>%
	# dplyr::rename(tss_id = custom_id) %>%
  # dplyr::rename(alt_id = alt_id.x) %>%
	# dplyr::select(TF_name, TF_bnumber, start, stop, alt_id, tu_id, tss_id, effect, evidence, confidence) 
	dplyr::select(TF_name, TF_bnumber, start, stop, alt_id, effect, evidence, confidence) 

# regu_bs_formatted_na <- regu_bs_formatted %>% filter(is.na(start)|is.na(stop))

regu_bs_formatted_to_merge <- regu_bs_formatted %>% filter(!is.na(start)|!is.na(stop)) %>%
	dplyr::mutate(unique_bs = paste0(TF_bnumber, "_", start, "_", stop, "_", effect))

query <- "select 
  group_concat(distinct TF_name) as TF_name,
  group_concat(distinct TF_bnumber) as TF_bnumber,
  min(start) as start,
  min(stop) as stop,
  group_concat(distinct alt_id) as alt_id,
  group_concat(distinct effect) as effect,
  group_concat(distinct evidence) as evidence,
  group_concat(distinct confidence) as confidence
from regu_bs_formatted_to_merge 
group by unique_bs
order by start"
 
regu_bs_filtered_duplicate <- sqldf::sqldf(query)

# regu_bs_filtered_duplicate_nas <- rbind.data.frame(regu_bs_formatted_na, regu_bs_filtered_duplicate)

tfbs_set <- regu_bs_filtered_duplicate %>%
  dplyr::mutate(tfbs_id = paste0("CTFBS", row_number()),
                type = "TFBS") %>%
  dplyr::left_join(master_gene_set %>% select(Consensus_bnumber, Zika_gene_id), by = c("TF_bnumber" = "Consensus_bnumber")) %>%
  dplyr::select(tfbs_id, start, stop, TF_name, TF_bnumber, effect, evidence, confidence, type, alt_id, Zika_gene_id)


## TFs that have >= 4 bs (but may include duplicate coords)
## bs_set %>% group_by(TF_name) %>% summarise(count = n()) %>% filter(count >= 4) %>% arrange(desc(count))
	
##  Create id mapping table
# bs_id_mapping_table <- regu_bs_ided %>%
# 	dplyr::select(bs_id, alt_id)

## Create bs-tu table
# bs_tu_mapping_table <- regu_bs_ided %>%
# 	dplyr::select(bs_id, tu_id) %>%
# 	# dplyr::rename(site_id = custom_id) %>%
# 	tidyr::separate_rows(tu_id, sep = ",") %>%
#   group_by(bs_id, tu_id) %>% 
#   filter(n() == 1)

## Create bs-tss table
# bs_tss_mapping_table <- regu_bs_ided %>%
# 	dplyr::select(bs_id, tss_id) %>%
# 	# dplyr::rename(site_id = custom_id) %>%
# 	tidyr::separate_rows(tss_id, sep = ",") %>%
#   group_by(bs_id, tss_id) %>% 
#   filter(n() == 1)

# ## Create bed-formatted file 
# bs_bed <- regu_bs_ided %>%
#   dplyr::mutate(chromosome = "NC_000913.3") %>%
# 	dplyr::select(chromosome, start, stop, TF_name, custom_id, effect) %>% 
# 	dplyr::arrange(start) %>% 
# 	dplyr::filter(!is.na(start)) %>% 
# 	dplyr::filter(!is.na(stop))
```

```{r write-bs-files}
write.table(tfbs_set, file = tfbs_set_file, col.names = T,  row.names = F, quote = F, sep = "\t")
# write.table(bs_bed, file = bs_set_bed_file, col.names = F,  row.names = F, quote = F, sep = "\t")
# write.table(bs_id_mapping_table, file = bs_mapping_id_file, col.names = T,  row.names = F, quote = F, sep = "\t")
# write.table(bs_tss_mapping_table, file = bs_tss_mapping_file, col.names = T,  row.names = F, quote = F, sep = "\t")
# write.table(bs_tu_mapping_table, file = bs_tu_mapping_file, col.names = T,  row.names = F, quote = F, sep = "\t")
```

# Feature mapping

The following file is created:

```{r create-filenames-map}
feature_map_file <- paste0(feature_set_dir, "/feature_map_", date, ".tsv")

```

`r feature_map_file`

* **tss_id:** custom id (CTSSXXX)
* **tu_id:** custom id (CTUXXX)
* **tfbs_id:** custom id (CTFBSXXX)


```{r mapping-file}

feature_map <- all_tus %>%
  dplyr::select(alt_id, tss_id) %>%
  dplyr::full_join(tu_set %>% 
                     dplyr::select(alt_id, tu_id) %>% 
                     tidyr::separate_rows(alt_id, sep = ","), 
                   by = "alt_id") %>%
  dplyr::rowwise() %>%
  dplyr::mutate(TU_alt_id = strsplit(alt_id, split = "_")[[1]][1]) %>%
  dplyr::select(-alt_id) %>%
  dplyr::full_join(regu_bs %>%
                     dplyr::select(alt_id, TU_alt_id), 
                   by = "TU_alt_id") %>%
  dplyr::full_join(bs_set %>% 
                     dplyr::select(bs_id, alt_id),
                   by = "alt_id") %>%
  dplyr::select(-alt_id, -TU_alt_id) %>%
  dplyr::mutate_all(na_if,"") %>%
  dplyr::rowwise() %>%
  dplyr::mutate(nas = sum(is.na(c(tss_id, tu_id, bs_id)))) %>%
  dplyr::filter(nas < 2) %>%
  dplyr::select(-nas)

write.table(feature_map, file = feature_map_file, col.names = T,  row.names = F, quote = F, sep = "\t")

```

```{r save-session}
save.image(file = paste0("Feature_set_construction_", date, ".Rdata"))

```
